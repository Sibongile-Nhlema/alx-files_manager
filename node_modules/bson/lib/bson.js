"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UUID = exports.Timestamp = exports.ObjectId = exports.MinKey = exports.MaxKey = exports.Long = exports.Int32 = exports.EJSON = exports.Double = exports.Decimal128 = exports.DBRef = exports.Code = exports.Binary = exports.BSONVersionError = exports.BSONValue = exports.BSONType = exports.BSONSymbol = exports.BSONRuntimeError = exports.BSONRegExp = exports.BSONOffsetError = exports.BSONError = exports.BSON = void 0;
exports.calculateObjectSize = calculateObjectSize;
exports.deserialize = deserialize;
exports.deserializeStream = deserializeStream;
exports.onDemand = void 0;
exports.serialize = serialize;
exports.serializeWithBufferAndIndex = serializeWithBufferAndIndex;
exports.setInternalBufferSize = setInternalBufferSize;
var _Buffer$prototype;
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function isAnyArrayBuffer(value) {
  return ['[object ArrayBuffer]', '[object SharedArrayBuffer]'].includes(Object.prototype.toString.call(value));
}
function isUint8Array(value) {
  return Object.prototype.toString.call(value) === '[object Uint8Array]';
}
function isRegExp(d) {
  return Object.prototype.toString.call(d) === '[object RegExp]';
}
function isMap(d) {
  return Object.prototype.toString.call(d) === '[object Map]';
}
function isDate(d) {
  return Object.prototype.toString.call(d) === '[object Date]';
}
function defaultInspect(x, _options) {
  return JSON.stringify(x, function (k, v) {
    if (typeof v === 'bigint') {
      return {
        $numberLong: "".concat(v)
      };
    } else if (isMap(v)) {
      return Object.fromEntries(v);
    }
    return v;
  });
}
function getStylizeFunction(options) {
  var stylizeExists = options != null && _typeof(options) === 'object' && 'stylize' in options && typeof options.stylize === 'function';
  if (stylizeExists) {
    return options.stylize;
  }
}
var BSON_MAJOR_VERSION = 6;
var BSON_INT32_MAX = 0x7fffffff;
var BSON_INT32_MIN = -0x80000000;
var BSON_INT64_MAX = Math.pow(2, 63) - 1;
var BSON_INT64_MIN = -Math.pow(2, 63);
var JS_INT_MAX = Math.pow(2, 53);
var JS_INT_MIN = -Math.pow(2, 53);
var BSON_DATA_NUMBER = 1;
var BSON_DATA_STRING = 2;
var BSON_DATA_OBJECT = 3;
var BSON_DATA_ARRAY = 4;
var BSON_DATA_BINARY = 5;
var BSON_DATA_UNDEFINED = 6;
var BSON_DATA_OID = 7;
var BSON_DATA_BOOLEAN = 8;
var BSON_DATA_DATE = 9;
var BSON_DATA_NULL = 10;
var BSON_DATA_REGEXP = 11;
var BSON_DATA_DBPOINTER = 12;
var BSON_DATA_CODE = 13;
var BSON_DATA_SYMBOL = 14;
var BSON_DATA_CODE_W_SCOPE = 15;
var BSON_DATA_INT = 16;
var BSON_DATA_TIMESTAMP = 17;
var BSON_DATA_LONG = 18;
var BSON_DATA_DECIMAL128 = 19;
var BSON_DATA_MIN_KEY = 0xff;
var BSON_DATA_MAX_KEY = 0x7f;
var BSON_BINARY_SUBTYPE_DEFAULT = 0;
var BSON_BINARY_SUBTYPE_UUID_NEW = 4;
var BSONType = exports.BSONType = Object.freeze({
  "double": 1,
  string: 2,
  object: 3,
  array: 4,
  binData: 5,
  undefined: 6,
  objectId: 7,
  bool: 8,
  date: 9,
  "null": 10,
  regex: 11,
  dbPointer: 12,
  javascript: 13,
  symbol: 14,
  javascriptWithScope: 15,
  "int": 16,
  timestamp: 17,
  "long": 18,
  decimal: 19,
  minKey: -1,
  maxKey: 127
});
var BSONError = exports.BSONError = /*#__PURE__*/function (_Error) {
  function BSONError(message, options) {
    _classCallCheck(this, BSONError);
    return _callSuper(this, BSONError, [message, options]);
  }
  _inherits(BSONError, _Error);
  return _createClass(BSONError, [{
    key: "bsonError",
    get: function get() {
      return true;
    }
  }, {
    key: "name",
    get: function get() {
      return 'BSONError';
    }
  }], [{
    key: "isBSONError",
    value: function isBSONError(value) {
      return value != null && _typeof(value) === 'object' && 'bsonError' in value && value.bsonError === true && 'name' in value && 'message' in value && 'stack' in value;
    }
  }]);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var BSONVersionError = exports.BSONVersionError = /*#__PURE__*/function (_BSONError) {
  function BSONVersionError() {
    _classCallCheck(this, BSONVersionError);
    return _callSuper(this, BSONVersionError, ["Unsupported BSON version, bson types must be from bson ".concat(BSON_MAJOR_VERSION, ".x.x")]);
  }
  _inherits(BSONVersionError, _BSONError);
  return _createClass(BSONVersionError, [{
    key: "name",
    get: function get() {
      return 'BSONVersionError';
    }
  }]);
}(BSONError);
var BSONRuntimeError = exports.BSONRuntimeError = /*#__PURE__*/function (_BSONError2) {
  function BSONRuntimeError(message) {
    _classCallCheck(this, BSONRuntimeError);
    return _callSuper(this, BSONRuntimeError, [message]);
  }
  _inherits(BSONRuntimeError, _BSONError2);
  return _createClass(BSONRuntimeError, [{
    key: "name",
    get: function get() {
      return 'BSONRuntimeError';
    }
  }]);
}(BSONError);
var BSONOffsetError = exports.BSONOffsetError = /*#__PURE__*/function (_BSONError3) {
  function BSONOffsetError(message, offset, options) {
    var _this;
    _classCallCheck(this, BSONOffsetError);
    _this = _callSuper(this, BSONOffsetError, ["".concat(message, ". offset: ").concat(offset), options]);
    _this.offset = offset;
    return _this;
  }
  _inherits(BSONOffsetError, _BSONError3);
  return _createClass(BSONOffsetError, [{
    key: "name",
    get: function get() {
      return 'BSONOffsetError';
    }
  }]);
}(BSONError);
var TextDecoderFatal;
var TextDecoderNonFatal;
function parseUtf8(buffer, start, end, fatal) {
  var _TextDecoderNonFatal;
  if (fatal) {
    var _TextDecoderFatal;
    (_TextDecoderFatal = TextDecoderFatal) !== null && _TextDecoderFatal !== void 0 ? _TextDecoderFatal : TextDecoderFatal = new TextDecoder('utf8', {
      fatal: true
    });
    try {
      return TextDecoderFatal.decode(buffer.subarray(start, end));
    } catch (cause) {
      throw new BSONError('Invalid UTF-8 string in BSON document', {
        cause: cause
      });
    }
  }
  (_TextDecoderNonFatal = TextDecoderNonFatal) !== null && _TextDecoderNonFatal !== void 0 ? _TextDecoderNonFatal : TextDecoderNonFatal = new TextDecoder('utf8', {
    fatal: false
  });
  return TextDecoderNonFatal.decode(buffer.subarray(start, end));
}
function tryReadBasicLatin(uint8array, start, end) {
  if (uint8array.length === 0) {
    return '';
  }
  var stringByteLength = end - start;
  if (stringByteLength === 0) {
    return '';
  }
  if (stringByteLength > 20) {
    return null;
  }
  if (stringByteLength === 1 && uint8array[start] < 128) {
    return String.fromCharCode(uint8array[start]);
  }
  if (stringByteLength === 2 && uint8array[start] < 128 && uint8array[start + 1] < 128) {
    return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]);
  }
  if (stringByteLength === 3 && uint8array[start] < 128 && uint8array[start + 1] < 128 && uint8array[start + 2] < 128) {
    return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]) + String.fromCharCode(uint8array[start + 2]);
  }
  var latinBytes = [];
  for (var i = start; i < end; i++) {
    var _byte = uint8array[i];
    if (_byte > 127) {
      return null;
    }
    latinBytes.push(_byte);
  }
  return String.fromCharCode.apply(String, latinBytes);
}
function tryWriteBasicLatin(destination, source, offset) {
  if (source.length === 0) return 0;
  if (source.length > 25) return null;
  if (destination.length - offset < source.length) return null;
  for (var charOffset = 0, destinationOffset = offset; charOffset < source.length; charOffset++, destinationOffset++) {
    var _char = source.charCodeAt(charOffset);
    if (_char > 127) return null;
    destination[destinationOffset] = _char;
  }
  return source.length;
}
function nodejsMathRandomBytes(byteLength) {
  return nodeJsByteUtils.fromNumberArray(Array.from({
    length: byteLength
  }, function () {
    return Math.floor(Math.random() * 256);
  }));
}
var nodejsRandomBytes = await _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
  return _regeneratorRuntime().wrap(function _callee$(_context) {
    while (1) switch (_context.prev = _context.next) {
      case 0:
        _context.prev = 0;
        _context.next = 3;
        return Promise.resolve().then(function () {
          return _interopRequireWildcard(require('crypto'));
        });
      case 3:
        return _context.abrupt("return", _context.sent.randomBytes);
      case 6:
        _context.prev = 6;
        _context.t0 = _context["catch"](0);
        return _context.abrupt("return", nodejsMathRandomBytes);
      case 9:
      case "end":
        return _context.stop();
    }
  }, _callee, null, [[0, 6]]);
}))();
var nodeJsByteUtils = {
  toLocalBufferType: function toLocalBufferType(potentialBuffer) {
    var _potentialBuffer$Symb;
    if (Buffer.isBuffer(potentialBuffer)) {
      return potentialBuffer;
    }
    if (ArrayBuffer.isView(potentialBuffer)) {
      return Buffer.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);
    }
    var stringTag = (_potentialBuffer$Symb = potentialBuffer === null || potentialBuffer === void 0 ? void 0 : potentialBuffer[Symbol.toStringTag]) !== null && _potentialBuffer$Symb !== void 0 ? _potentialBuffer$Symb : Object.prototype.toString.call(potentialBuffer);
    if (stringTag === 'ArrayBuffer' || stringTag === 'SharedArrayBuffer' || stringTag === '[object ArrayBuffer]' || stringTag === '[object SharedArrayBuffer]') {
      return Buffer.from(potentialBuffer);
    }
    throw new BSONError("Cannot create Buffer from ".concat(String(potentialBuffer)));
  },
  allocate: function allocate(size) {
    return Buffer.alloc(size);
  },
  allocateUnsafe: function allocateUnsafe(size) {
    return Buffer.allocUnsafe(size);
  },
  equals: function equals(a, b) {
    return nodeJsByteUtils.toLocalBufferType(a).equals(b);
  },
  fromNumberArray: function fromNumberArray(array) {
    return Buffer.from(array);
  },
  fromBase64: function fromBase64(base64) {
    return Buffer.from(base64, 'base64');
  },
  toBase64: function toBase64(buffer) {
    return nodeJsByteUtils.toLocalBufferType(buffer).toString('base64');
  },
  fromISO88591: function fromISO88591(codePoints) {
    return Buffer.from(codePoints, 'binary');
  },
  toISO88591: function toISO88591(buffer) {
    return nodeJsByteUtils.toLocalBufferType(buffer).toString('binary');
  },
  fromHex: function fromHex(hex) {
    return Buffer.from(hex, 'hex');
  },
  toHex: function toHex(buffer) {
    return nodeJsByteUtils.toLocalBufferType(buffer).toString('hex');
  },
  toUTF8: function toUTF8(buffer, start, end, fatal) {
    var basicLatin = end - start <= 20 ? tryReadBasicLatin(buffer, start, end) : null;
    if (basicLatin != null) {
      return basicLatin;
    }
    var string = nodeJsByteUtils.toLocalBufferType(buffer).toString('utf8', start, end);
    if (fatal) {
      for (var i = 0; i < string.length; i++) {
        if (string.charCodeAt(i) === 0xfffd) {
          parseUtf8(buffer, start, end, true);
          break;
        }
      }
    }
    return string;
  },
  utf8ByteLength: function utf8ByteLength(input) {
    return Buffer.byteLength(input, 'utf8');
  },
  encodeUTF8Into: function encodeUTF8Into(buffer, source, byteOffset) {
    var latinBytesWritten = tryWriteBasicLatin(buffer, source, byteOffset);
    if (latinBytesWritten != null) {
      return latinBytesWritten;
    }
    return nodeJsByteUtils.toLocalBufferType(buffer).write(source, byteOffset, undefined, 'utf8');
  },
  randomBytes: nodejsRandomBytes
};
function isReactNative() {
  var navigator = globalThis.navigator;
  return _typeof(navigator) === 'object' && navigator.product === 'ReactNative';
}
function webMathRandomBytes(byteLength) {
  if (byteLength < 0) {
    throw new RangeError("The argument 'byteLength' is invalid. Received ".concat(byteLength));
  }
  return webByteUtils.fromNumberArray(Array.from({
    length: byteLength
  }, function () {
    return Math.floor(Math.random() * 256);
  }));
}
var webRandomBytes = function () {
  var crypto = globalThis.crypto;
  if (crypto != null && typeof crypto.getRandomValues === 'function') {
    return function (byteLength) {
      return crypto.getRandomValues(webByteUtils.allocate(byteLength));
    };
  } else {
    if (isReactNative()) {
      var _console$warn;
      var console = globalThis.console;
      console === null || console === void 0 || (_console$warn = console.warn) === null || _console$warn === void 0 || _console$warn.call(console, 'BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.');
    }
    return webMathRandomBytes;
  }
}();
var HEX_DIGIT = /(\d|[a-f])/i;
var webByteUtils = {
  toLocalBufferType: function toLocalBufferType(potentialUint8array) {
    var _potentialUint8array$;
    var stringTag = (_potentialUint8array$ = potentialUint8array === null || potentialUint8array === void 0 ? void 0 : potentialUint8array[Symbol.toStringTag]) !== null && _potentialUint8array$ !== void 0 ? _potentialUint8array$ : Object.prototype.toString.call(potentialUint8array);
    if (stringTag === 'Uint8Array') {
      return potentialUint8array;
    }
    if (ArrayBuffer.isView(potentialUint8array)) {
      return new Uint8Array(potentialUint8array.buffer.slice(potentialUint8array.byteOffset, potentialUint8array.byteOffset + potentialUint8array.byteLength));
    }
    if (stringTag === 'ArrayBuffer' || stringTag === 'SharedArrayBuffer' || stringTag === '[object ArrayBuffer]' || stringTag === '[object SharedArrayBuffer]') {
      return new Uint8Array(potentialUint8array);
    }
    throw new BSONError("Cannot make a Uint8Array from ".concat(String(potentialUint8array)));
  },
  allocate: function allocate(size) {
    if (typeof size !== 'number') {
      throw new TypeError("The \"size\" argument must be of type number. Received ".concat(String(size)));
    }
    return new Uint8Array(size);
  },
  allocateUnsafe: function allocateUnsafe(size) {
    return webByteUtils.allocate(size);
  },
  equals: function equals(a, b) {
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (var i = 0; i < a.byteLength; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  },
  fromNumberArray: function fromNumberArray(array) {
    return Uint8Array.from(array);
  },
  fromBase64: function fromBase64(base64) {
    return Uint8Array.from(atob(base64), function (c) {
      return c.charCodeAt(0);
    });
  },
  toBase64: function toBase64(uint8array) {
    return btoa(webByteUtils.toISO88591(uint8array));
  },
  fromISO88591: function fromISO88591(codePoints) {
    return Uint8Array.from(codePoints, function (c) {
      return c.charCodeAt(0) & 0xff;
    });
  },
  toISO88591: function toISO88591(uint8array) {
    return Array.from(Uint16Array.from(uint8array), function (b) {
      return String.fromCharCode(b);
    }).join('');
  },
  fromHex: function fromHex(hex) {
    var evenLengthHex = hex.length % 2 === 0 ? hex : hex.slice(0, hex.length - 1);
    var buffer = [];
    for (var i = 0; i < evenLengthHex.length; i += 2) {
      var firstDigit = evenLengthHex[i];
      var secondDigit = evenLengthHex[i + 1];
      if (!HEX_DIGIT.test(firstDigit)) {
        break;
      }
      if (!HEX_DIGIT.test(secondDigit)) {
        break;
      }
      var hexDigit = Number.parseInt("".concat(firstDigit).concat(secondDigit), 16);
      buffer.push(hexDigit);
    }
    return Uint8Array.from(buffer);
  },
  toHex: function toHex(uint8array) {
    return Array.from(uint8array, function (_byte2) {
      return _byte2.toString(16).padStart(2, '0');
    }).join('');
  },
  toUTF8: function toUTF8(uint8array, start, end, fatal) {
    var basicLatin = end - start <= 20 ? tryReadBasicLatin(uint8array, start, end) : null;
    if (basicLatin != null) {
      return basicLatin;
    }
    return parseUtf8(uint8array, start, end, fatal);
  },
  utf8ByteLength: function utf8ByteLength(input) {
    return new TextEncoder().encode(input).byteLength;
  },
  encodeUTF8Into: function encodeUTF8Into(uint8array, source, byteOffset) {
    var bytes = new TextEncoder().encode(source);
    uint8array.set(bytes, byteOffset);
    return bytes.byteLength;
  },
  randomBytes: webRandomBytes
};
var hasGlobalBuffer = typeof Buffer === 'function' && ((_Buffer$prototype = Buffer.prototype) === null || _Buffer$prototype === void 0 ? void 0 : _Buffer$prototype._isBuffer) !== true;
var ByteUtils = hasGlobalBuffer ? nodeJsByteUtils : webByteUtils;
var BSONValue = exports.BSONValue = /*#__PURE__*/function () {
  function BSONValue() {
    _classCallCheck(this, BSONValue);
  }
  return _createClass(BSONValue, [{
    key: Symbol["for"]('@@mdb.bson.version'),
    get: function get() {
      return BSON_MAJOR_VERSION;
    }
  }, {
    key: Symbol["for"]('nodejs.util.inspect.custom'),
    value: function value(depth, options, inspect) {
      return this.inspect(depth, options, inspect);
    }
  }]);
}();
var _Binary2 = exports.Binary = /*#__PURE__*/function (_BSONValue) {
  function Binary(buffer, subType) {
    var _this2;
    _classCallCheck(this, Binary);
    _this2 = _callSuper(this, Binary);
    if (!(buffer == null) && typeof buffer === 'string' && !ArrayBuffer.isView(buffer) && !isAnyArrayBuffer(buffer) && !Array.isArray(buffer)) {
      throw new BSONError('Binary can only be constructed from Uint8Array or number[]');
    }
    _this2.sub_type = subType !== null && subType !== void 0 ? subType : Binary.BSON_BINARY_SUBTYPE_DEFAULT;
    if (buffer == null) {
      _this2.buffer = ByteUtils.allocate(Binary.BUFFER_SIZE);
      _this2.position = 0;
    } else {
      _this2.buffer = Array.isArray(buffer) ? ByteUtils.fromNumberArray(buffer) : ByteUtils.toLocalBufferType(buffer);
      _this2.position = _this2.buffer.byteLength;
    }
    return _this2;
  }
  _inherits(Binary, _BSONValue);
  return _createClass(Binary, [{
    key: "_bsontype",
    get: function get() {
      return 'Binary';
    }
  }, {
    key: "put",
    value: function put(byteValue) {
      if (typeof byteValue === 'string' && byteValue.length !== 1) {
        throw new BSONError('only accepts single character String');
      } else if (typeof byteValue !== 'number' && byteValue.length !== 1) throw new BSONError('only accepts single character Uint8Array or Array');
      var decodedByte;
      if (typeof byteValue === 'string') {
        decodedByte = byteValue.charCodeAt(0);
      } else if (typeof byteValue === 'number') {
        decodedByte = byteValue;
      } else {
        decodedByte = byteValue[0];
      }
      if (decodedByte < 0 || decodedByte > 255) {
        throw new BSONError('only accepts number in a valid unsigned byte range 0-255');
      }
      if (this.buffer.byteLength > this.position) {
        this.buffer[this.position++] = decodedByte;
      } else {
        var newSpace = ByteUtils.allocate(Binary.BUFFER_SIZE + this.buffer.length);
        newSpace.set(this.buffer, 0);
        this.buffer = newSpace;
        this.buffer[this.position++] = decodedByte;
      }
    }
  }, {
    key: "write",
    value: function write(sequence, offset) {
      offset = typeof offset === 'number' ? offset : this.position;
      if (this.buffer.byteLength < offset + sequence.length) {
        var newSpace = ByteUtils.allocate(this.buffer.byteLength + sequence.length);
        newSpace.set(this.buffer, 0);
        this.buffer = newSpace;
      }
      if (ArrayBuffer.isView(sequence)) {
        this.buffer.set(ByteUtils.toLocalBufferType(sequence), offset);
        this.position = offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;
      } else if (typeof sequence === 'string') {
        throw new BSONError('input cannot be string');
      }
    }
  }, {
    key: "read",
    value: function read(position, length) {
      length = length && length > 0 ? length : this.position;
      return this.buffer.slice(position, position + length);
    }
  }, {
    key: "value",
    value: function value() {
      return this.buffer.length === this.position ? this.buffer : this.buffer.subarray(0, this.position);
    }
  }, {
    key: "length",
    value: function length() {
      return this.position;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return ByteUtils.toBase64(this.buffer.subarray(0, this.position));
    }
  }, {
    key: "toString",
    value: function toString(encoding) {
      if (encoding === 'hex') return ByteUtils.toHex(this.buffer.subarray(0, this.position));
      if (encoding === 'base64') return ByteUtils.toBase64(this.buffer.subarray(0, this.position));
      if (encoding === 'utf8' || encoding === 'utf-8') return ByteUtils.toUTF8(this.buffer, 0, this.position, false);
      return ByteUtils.toUTF8(this.buffer, 0, this.position, false);
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON(options) {
      options = options || {};
      var base64String = ByteUtils.toBase64(this.buffer);
      var subType = Number(this.sub_type).toString(16);
      if (options.legacy) {
        return {
          $binary: base64String,
          $type: subType.length === 1 ? '0' + subType : subType
        };
      }
      return {
        $binary: {
          base64: base64String,
          subType: subType.length === 1 ? '0' + subType : subType
        }
      };
    }
  }, {
    key: "toUUID",
    value: function toUUID() {
      if (this.sub_type === Binary.SUBTYPE_UUID) {
        return new UUID(this.buffer.slice(0, this.position));
      }
      throw new BSONError("Binary sub_type \"".concat(this.sub_type, "\" is not supported for converting to UUID. Only \"").concat(Binary.SUBTYPE_UUID, "\" is currently supported."));
    }
  }, {
    key: "inspect",
    value: function inspect(depth, options, _inspect) {
      var _inspect2;
      (_inspect2 = _inspect) !== null && _inspect2 !== void 0 ? _inspect2 : _inspect = defaultInspect;
      var base64 = ByteUtils.toBase64(this.buffer.subarray(0, this.position));
      var base64Arg = _inspect(base64, options);
      var subTypeArg = _inspect(this.sub_type, options);
      return "Binary.createFromBase64(".concat(base64Arg, ", ").concat(subTypeArg, ")");
    }
  }], [{
    key: "createFromHexString",
    value: function createFromHexString(hex, subType) {
      return new Binary(ByteUtils.fromHex(hex), subType);
    }
  }, {
    key: "createFromBase64",
    value: function createFromBase64(base64, subType) {
      return new Binary(ByteUtils.fromBase64(base64), subType);
    }
  }, {
    key: "fromExtendedJSON",
    value: function fromExtendedJSON(doc, options) {
      options = options || {};
      var data;
      var type;
      if ('$binary' in doc) {
        if (options.legacy && typeof doc.$binary === 'string' && '$type' in doc) {
          type = doc.$type ? parseInt(doc.$type, 16) : 0;
          data = ByteUtils.fromBase64(doc.$binary);
        } else {
          if (typeof doc.$binary !== 'string') {
            type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;
            data = ByteUtils.fromBase64(doc.$binary.base64);
          }
        }
      } else if ('$uuid' in doc) {
        type = 4;
        data = UUID.bytesFromString(doc.$uuid);
      }
      if (!data) {
        throw new BSONError("Unexpected Binary Extended JSON format ".concat(JSON.stringify(doc)));
      }
      return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary(data, type);
    }
  }]);
}(BSONValue);
_Binary2.BSON_BINARY_SUBTYPE_DEFAULT = 0;
_Binary2.BUFFER_SIZE = 256;
_Binary2.SUBTYPE_DEFAULT = 0;
_Binary2.SUBTYPE_FUNCTION = 1;
_Binary2.SUBTYPE_BYTE_ARRAY = 2;
_Binary2.SUBTYPE_UUID_OLD = 3;
_Binary2.SUBTYPE_UUID = 4;
_Binary2.SUBTYPE_MD5 = 5;
_Binary2.SUBTYPE_ENCRYPTED = 6;
_Binary2.SUBTYPE_COLUMN = 7;
_Binary2.SUBTYPE_SENSITIVE = 8;
_Binary2.SUBTYPE_USER_DEFINED = 128;
var UUID_BYTE_LENGTH = 16;
var UUID_WITHOUT_DASHES = /^[0-9A-F]{32}$/i;
var UUID_WITH_DASHES = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;
var UUID = exports.UUID = /*#__PURE__*/function (_Binary) {
  function UUID(input) {
    _classCallCheck(this, UUID);
    var bytes;
    if (input == null) {
      bytes = UUID.generate();
    } else if (input instanceof UUID) {
      bytes = ByteUtils.toLocalBufferType(new Uint8Array(input.buffer));
    } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {
      bytes = ByteUtils.toLocalBufferType(input);
    } else if (typeof input === 'string') {
      bytes = UUID.bytesFromString(input);
    } else {
      throw new BSONError('Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).');
    }
    return _callSuper(this, UUID, [bytes, BSON_BINARY_SUBTYPE_UUID_NEW]);
  }
  _inherits(UUID, _Binary);
  return _createClass(UUID, [{
    key: "id",
    get: function get() {
      return this.buffer;
    },
    set: function set(value) {
      this.buffer = value;
    }
  }, {
    key: "toHexString",
    value: function toHexString() {
      var includeDashes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (includeDashes) {
        return [ByteUtils.toHex(this.buffer.subarray(0, 4)), ByteUtils.toHex(this.buffer.subarray(4, 6)), ByteUtils.toHex(this.buffer.subarray(6, 8)), ByteUtils.toHex(this.buffer.subarray(8, 10)), ByteUtils.toHex(this.buffer.subarray(10, 16))].join('-');
      }
      return ByteUtils.toHex(this.buffer);
    }
  }, {
    key: "toString",
    value: function toString(encoding) {
      if (encoding === 'hex') return ByteUtils.toHex(this.id);
      if (encoding === 'base64') return ByteUtils.toBase64(this.id);
      return this.toHexString();
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.toHexString();
    }
  }, {
    key: "equals",
    value: function equals(otherId) {
      if (!otherId) {
        return false;
      }
      if (otherId instanceof UUID) {
        return ByteUtils.equals(otherId.id, this.id);
      }
      try {
        return ByteUtils.equals(new UUID(otherId).id, this.id);
      } catch (_unused2) {
        return false;
      }
    }
  }, {
    key: "toBinary",
    value: function toBinary() {
      return new _Binary2(this.id, _Binary2.SUBTYPE_UUID);
    }
  }, {
    key: "inspect",
    value: function inspect(depth, options, _inspect3) {
      var _inspect4;
      (_inspect4 = _inspect3) !== null && _inspect4 !== void 0 ? _inspect4 : _inspect3 = defaultInspect;
      return "new UUID(".concat(_inspect3(this.toHexString(), options), ")");
    }
  }], [{
    key: "generate",
    value: function generate() {
      var bytes = ByteUtils.randomBytes(UUID_BYTE_LENGTH);
      bytes[6] = bytes[6] & 0x0f | 0x40;
      bytes[8] = bytes[8] & 0x3f | 0x80;
      return bytes;
    }
  }, {
    key: "isValid",
    value: function isValid(input) {
      if (!input) {
        return false;
      }
      if (typeof input === 'string') {
        return UUID.isValidUUIDString(input);
      }
      if (isUint8Array(input)) {
        return input.byteLength === UUID_BYTE_LENGTH;
      }
      return input._bsontype === 'Binary' && input.sub_type === this.SUBTYPE_UUID && input.buffer.byteLength === 16;
    }
  }, {
    key: "createFromHexString",
    value: function createFromHexString(hexString) {
      var buffer = UUID.bytesFromString(hexString);
      return new UUID(buffer);
    }
  }, {
    key: "createFromBase64",
    value: function createFromBase64(base64) {
      return new UUID(ByteUtils.fromBase64(base64));
    }
  }, {
    key: "bytesFromString",
    value: function bytesFromString(representation) {
      if (!UUID.isValidUUIDString(representation)) {
        throw new BSONError('UUID string representation must be 32 hex digits or canonical hyphenated representation');
      }
      return ByteUtils.fromHex(representation.replace(/-/g, ''));
    }
  }, {
    key: "isValidUUIDString",
    value: function isValidUUIDString(representation) {
      return UUID_WITHOUT_DASHES.test(representation) || UUID_WITH_DASHES.test(representation);
    }
  }]);
}(_Binary2);
var _Code = exports.Code = /*#__PURE__*/function (_BSONValue2) {
  function Code(code, scope) {
    var _this3;
    _classCallCheck(this, Code);
    _this3 = _callSuper(this, Code);
    _this3.code = code.toString();
    _this3.scope = scope !== null && scope !== void 0 ? scope : null;
    return _this3;
  }
  _inherits(Code, _BSONValue2);
  return _createClass(Code, [{
    key: "_bsontype",
    get: function get() {
      return 'Code';
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      if (this.scope != null) {
        return {
          code: this.code,
          scope: this.scope
        };
      }
      return {
        code: this.code
      };
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON() {
      if (this.scope) {
        return {
          $code: this.code,
          $scope: this.scope
        };
      }
      return {
        $code: this.code
      };
    }
  }, {
    key: "inspect",
    value: function inspect(depth, options, _inspect5) {
      var _inspect6;
      (_inspect6 = _inspect5) !== null && _inspect6 !== void 0 ? _inspect6 : _inspect5 = defaultInspect;
      var parametersString = _inspect5(this.code, options);
      var multiLineFn = parametersString.includes('\n');
      if (this.scope != null) {
        parametersString += ",".concat(multiLineFn ? '\n' : ' ').concat(_inspect5(this.scope, options));
      }
      var endingNewline = multiLineFn && this.scope === null;
      return "new Code(".concat(multiLineFn ? '\n' : '').concat(parametersString).concat(endingNewline ? '\n' : '', ")");
    }
  }], [{
    key: "fromExtendedJSON",
    value: function fromExtendedJSON(doc) {
      return new Code(doc.$code, doc.$scope);
    }
  }]);
}(BSONValue);
function isDBRefLike(value) {
  return value != null && _typeof(value) === 'object' && '$id' in value && value.$id != null && '$ref' in value && typeof value.$ref === 'string' && (!('$db' in value) || '$db' in value && typeof value.$db === 'string');
}
var _DBRef = exports.DBRef = /*#__PURE__*/function (_BSONValue3) {
  function DBRef(collection, oid, db, fields) {
    var _this4;
    _classCallCheck(this, DBRef);
    _this4 = _callSuper(this, DBRef);
    var parts = collection.split('.');
    if (parts.length === 2) {
      db = parts.shift();
      collection = parts.shift();
    }
    _this4.collection = collection;
    _this4.oid = oid;
    _this4.db = db;
    _this4.fields = fields || {};
    return _this4;
  }
  _inherits(DBRef, _BSONValue3);
  return _createClass(DBRef, [{
    key: "_bsontype",
    get: function get() {
      return 'DBRef';
    }
  }, {
    key: "namespace",
    get: function get() {
      return this.collection;
    },
    set: function set(value) {
      this.collection = value;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var o = Object.assign({
        $ref: this.collection,
        $id: this.oid
      }, this.fields);
      if (this.db != null) o.$db = this.db;
      return o;
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON(options) {
      options = options || {};
      var o = {
        $ref: this.collection,
        $id: this.oid
      };
      if (options.legacy) {
        return o;
      }
      if (this.db) o.$db = this.db;
      o = Object.assign(o, this.fields);
      return o;
    }
  }, {
    key: "inspect",
    value: function inspect(depth, options, _inspect7) {
      var _inspect8;
      (_inspect8 = _inspect7) !== null && _inspect8 !== void 0 ? _inspect8 : _inspect7 = defaultInspect;
      var args = [_inspect7(this.namespace, options), _inspect7(this.oid, options)].concat(_toConsumableArray(this.db ? [_inspect7(this.db, options)] : []), _toConsumableArray(Object.keys(this.fields).length > 0 ? [_inspect7(this.fields, options)] : []));
      args[1] = _inspect7 === defaultInspect ? "new ObjectId(".concat(args[1], ")") : args[1];
      return "new DBRef(".concat(args.join(', '), ")");
    }
  }], [{
    key: "fromExtendedJSON",
    value: function fromExtendedJSON(doc) {
      var copy = Object.assign({}, doc);
      delete copy.$ref;
      delete copy.$id;
      delete copy.$db;
      return new DBRef(doc.$ref, doc.$id, doc.$db, copy);
    }
  }]);
}(BSONValue);
function removeLeadingZerosAndExplicitPlus(str) {
  if (str === '') {
    return str;
  }
  var startIndex = 0;
  var isNegative = str[startIndex] === '-';
  var isExplicitlyPositive = str[startIndex] === '+';
  if (isExplicitlyPositive || isNegative) {
    startIndex += 1;
  }
  var foundInsignificantZero = false;
  for (; startIndex < str.length && str[startIndex] === '0'; ++startIndex) {
    foundInsignificantZero = true;
  }
  if (!foundInsignificantZero) {
    return isExplicitlyPositive ? str.slice(1) : str;
  }
  return "".concat(isNegative ? '-' : '').concat(str.length === startIndex ? '0' : str.slice(startIndex));
}
function validateStringCharacters(str, radix) {
  var _radix;
  radix = (_radix = radix) !== null && _radix !== void 0 ? _radix : 10;
  var validCharacters = '0123456789abcdefghijklmnopqrstuvwxyz'.slice(0, radix);
  var regex = new RegExp("[^-+".concat(validCharacters, "]"), 'i');
  return regex.test(str) ? false : str;
}
var wasm = undefined;
try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
} catch (_unused3) {}
var TWO_PWR_16_DBL = 1 << 16;
var TWO_PWR_24_DBL = 1 << 24;
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
var INT_CACHE = {};
var UINT_CACHE = {};
var MAX_INT64_STRING_LENGTH = 20;
var DECIMAL_REG_EX = /^(\+?0|(\+|-)?[1-9][0-9]*)$/;
var _Long = exports.Long = /*#__PURE__*/function (_BSONValue4) {
  function Long() {
    var _this5;
    var lowOrValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var highOrUnsigned = arguments.length > 1 ? arguments[1] : undefined;
    var unsigned = arguments.length > 2 ? arguments[2] : undefined;
    _classCallCheck(this, Long);
    _this5 = _callSuper(this, Long);
    var unsignedBool = typeof highOrUnsigned === 'boolean' ? highOrUnsigned : Boolean(unsigned);
    var high = typeof highOrUnsigned === 'number' ? highOrUnsigned : 0;
    var res = typeof lowOrValue === 'string' ? Long.fromString(lowOrValue, unsignedBool) : typeof lowOrValue === 'bigint' ? Long.fromBigInt(lowOrValue, unsignedBool) : {
      low: lowOrValue | 0,
      high: high | 0,
      unsigned: unsignedBool
    };
    _this5.low = res.low;
    _this5.high = res.high;
    _this5.unsigned = res.unsigned;
    return _this5;
  }
  _inherits(Long, _BSONValue4);
  return _createClass(Long, [{
    key: "_bsontype",
    get: function get() {
      return 'Long';
    }
  }, {
    key: "__isLong__",
    get: function get() {
      return true;
    }
  }, {
    key: "add",
    value: function add(addend) {
      if (!Long.isLong(addend)) addend = Long.fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 0xffff;
      var a16 = this.low >>> 16;
      var a00 = this.low & 0xffff;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 0xffff;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 0xffff;
      var c48 = 0,
        c32 = 0,
        c16 = 0,
        c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 0xffff;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 0xffff;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c48 += a48 + b48;
      c48 &= 0xffff;
      return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    }
  }, {
    key: "and",
    value: function and(other) {
      if (!Long.isLong(other)) other = Long.fromValue(other);
      return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    }
  }, {
    key: "compare",
    value: function compare(other) {
      if (!Long.isLong(other)) other = Long.fromValue(other);
      if (this.eq(other)) return 0;
      var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
      if (thisNeg && !otherNeg) return -1;
      if (!thisNeg && otherNeg) return 1;
      if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    }
  }, {
    key: "comp",
    value: function comp(other) {
      return this.compare(other);
    }
  }, {
    key: "divide",
    value: function divide(divisor) {
      if (!Long.isLong(divisor)) divisor = Long.fromValue(divisor);
      if (divisor.isZero()) throw new BSONError('division by zero');
      if (wasm) {
        if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
        return Long.fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (this.isZero()) return this.unsigned ? Long.UZERO : Long.ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(Long.MIN_VALUE)) {
          if (divisor.eq(Long.ONE) || divisor.eq(Long.NEG_ONE)) return Long.MIN_VALUE;else if (divisor.eq(Long.MIN_VALUE)) return Long.ONE;else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(Long.ZERO)) {
              return divisor.isNegative() ? Long.ONE : Long.NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(Long.MIN_VALUE)) return this.unsigned ? Long.UZERO : Long.ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative()) return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
        res = Long.ZERO;
      } else {
        if (!divisor.unsigned) divisor = divisor.toUnsigned();
        if (divisor.gt(this)) return Long.UZERO;
        if (divisor.gt(this.shru(1))) return Long.UONE;
        res = Long.UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2);
        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
        var approxRes = Long.fromNumber(approx);
        var approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = Long.fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero()) approxRes = Long.ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    }
  }, {
    key: "div",
    value: function div(divisor) {
      return this.divide(divisor);
    }
  }, {
    key: "equals",
    value: function equals(other) {
      if (!Long.isLong(other)) other = Long.fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
      return this.high === other.high && this.low === other.low;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this.equals(other);
    }
  }, {
    key: "getHighBits",
    value: function getHighBits() {
      return this.high;
    }
  }, {
    key: "getHighBitsUnsigned",
    value: function getHighBitsUnsigned() {
      return this.high >>> 0;
    }
  }, {
    key: "getLowBits",
    value: function getLowBits() {
      return this.low;
    }
  }, {
    key: "getLowBitsUnsigned",
    value: function getLowBitsUnsigned() {
      return this.low >>> 0;
    }
  }, {
    key: "getNumBitsAbs",
    value: function getNumBitsAbs() {
      if (this.isNegative()) {
        return this.eq(Long.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      }
      var val = this.high !== 0 ? this.high : this.low;
      var bit;
      for (bit = 31; bit > 0; bit--) if ((val & 1 << bit) !== 0) break;
      return this.high !== 0 ? bit + 33 : bit + 1;
    }
  }, {
    key: "greaterThan",
    value: function greaterThan(other) {
      return this.comp(other) > 0;
    }
  }, {
    key: "gt",
    value: function gt(other) {
      return this.greaterThan(other);
    }
  }, {
    key: "greaterThanOrEqual",
    value: function greaterThanOrEqual(other) {
      return this.comp(other) >= 0;
    }
  }, {
    key: "gte",
    value: function gte(other) {
      return this.greaterThanOrEqual(other);
    }
  }, {
    key: "ge",
    value: function ge(other) {
      return this.greaterThanOrEqual(other);
    }
  }, {
    key: "isEven",
    value: function isEven() {
      return (this.low & 1) === 0;
    }
  }, {
    key: "isNegative",
    value: function isNegative() {
      return !this.unsigned && this.high < 0;
    }
  }, {
    key: "isOdd",
    value: function isOdd() {
      return (this.low & 1) === 1;
    }
  }, {
    key: "isPositive",
    value: function isPositive() {
      return this.unsigned || this.high >= 0;
    }
  }, {
    key: "isZero",
    value: function isZero() {
      return this.high === 0 && this.low === 0;
    }
  }, {
    key: "lessThan",
    value: function lessThan(other) {
      return this.comp(other) < 0;
    }
  }, {
    key: "lt",
    value: function lt(other) {
      return this.lessThan(other);
    }
  }, {
    key: "lessThanOrEqual",
    value: function lessThanOrEqual(other) {
      return this.comp(other) <= 0;
    }
  }, {
    key: "lte",
    value: function lte(other) {
      return this.lessThanOrEqual(other);
    }
  }, {
    key: "modulo",
    value: function modulo(divisor) {
      if (!Long.isLong(divisor)) divisor = Long.fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
        return Long.fromBits(low, wasm.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    }
  }, {
    key: "mod",
    value: function mod(divisor) {
      return this.modulo(divisor);
    }
  }, {
    key: "rem",
    value: function rem(divisor) {
      return this.modulo(divisor);
    }
  }, {
    key: "multiply",
    value: function multiply(multiplier) {
      if (this.isZero()) return Long.ZERO;
      if (!Long.isLong(multiplier)) multiplier = Long.fromValue(multiplier);
      if (wasm) {
        var low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
        return Long.fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (multiplier.isZero()) return Long.ZERO;
      if (this.eq(Long.MIN_VALUE)) return multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO;
      if (multiplier.eq(Long.MIN_VALUE)) return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());else return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();
      if (this.lt(Long.TWO_PWR_24) && multiplier.lt(Long.TWO_PWR_24)) return Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 0xffff;
      var a16 = this.low >>> 16;
      var a00 = this.low & 0xffff;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 0xffff;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 0xffff;
      var c48 = 0,
        c32 = 0,
        c16 = 0,
        c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 0xffff;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 0xffff;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 0xffff;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 0xffff;
      return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    }
  }, {
    key: "mul",
    value: function mul(multiplier) {
      return this.multiply(multiplier);
    }
  }, {
    key: "negate",
    value: function negate() {
      if (!this.unsigned && this.eq(Long.MIN_VALUE)) return Long.MIN_VALUE;
      return this.not().add(Long.ONE);
    }
  }, {
    key: "neg",
    value: function neg() {
      return this.negate();
    }
  }, {
    key: "not",
    value: function not() {
      return Long.fromBits(~this.low, ~this.high, this.unsigned);
    }
  }, {
    key: "notEquals",
    value: function notEquals(other) {
      return !this.equals(other);
    }
  }, {
    key: "neq",
    value: function neq(other) {
      return this.notEquals(other);
    }
  }, {
    key: "ne",
    value: function ne(other) {
      return this.notEquals(other);
    }
  }, {
    key: "or",
    value: function or(other) {
      if (!Long.isLong(other)) other = Long.fromValue(other);
      return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    }
  }, {
    key: "shiftLeft",
    value: function shiftLeft(numBits) {
      if (Long.isLong(numBits)) numBits = numBits.toInt();
      if ((numBits &= 63) === 0) return this;else if (numBits < 32) return Long.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);else return Long.fromBits(0, this.low << numBits - 32, this.unsigned);
    }
  }, {
    key: "shl",
    value: function shl(numBits) {
      return this.shiftLeft(numBits);
    }
  }, {
    key: "shiftRight",
    value: function shiftRight(numBits) {
      if (Long.isLong(numBits)) numBits = numBits.toInt();
      if ((numBits &= 63) === 0) return this;else if (numBits < 32) return Long.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);else return Long.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    }
  }, {
    key: "shr",
    value: function shr(numBits) {
      return this.shiftRight(numBits);
    }
  }, {
    key: "shiftRightUnsigned",
    value: function shiftRightUnsigned(numBits) {
      if (Long.isLong(numBits)) numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0) return this;else {
        var high = this.high;
        if (numBits < 32) {
          var low = this.low;
          return Long.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32) return Long.fromBits(high, 0, this.unsigned);else return Long.fromBits(high >>> numBits - 32, 0, this.unsigned);
      }
    }
  }, {
    key: "shr_u",
    value: function shr_u(numBits) {
      return this.shiftRightUnsigned(numBits);
    }
  }, {
    key: "shru",
    value: function shru(numBits) {
      return this.shiftRightUnsigned(numBits);
    }
  }, {
    key: "subtract",
    value: function subtract(subtrahend) {
      if (!Long.isLong(subtrahend)) subtrahend = Long.fromValue(subtrahend);
      return this.add(subtrahend.neg());
    }
  }, {
    key: "sub",
    value: function sub(subtrahend) {
      return this.subtract(subtrahend);
    }
  }, {
    key: "toInt",
    value: function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    }
  }, {
    key: "toNumber",
    value: function toNumber() {
      if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    }
  }, {
    key: "toBigInt",
    value: function toBigInt() {
      return BigInt(this.toString());
    }
  }, {
    key: "toBytes",
    value: function toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    }
  }, {
    key: "toBytesLE",
    value: function toBytesLE() {
      var hi = this.high,
        lo = this.low;
      return [lo & 0xff, lo >>> 8 & 0xff, lo >>> 16 & 0xff, lo >>> 24, hi & 0xff, hi >>> 8 & 0xff, hi >>> 16 & 0xff, hi >>> 24];
    }
  }, {
    key: "toBytesBE",
    value: function toBytesBE() {
      var hi = this.high,
        lo = this.low;
      return [hi >>> 24, hi >>> 16 & 0xff, hi >>> 8 & 0xff, hi & 0xff, lo >>> 24, lo >>> 16 & 0xff, lo >>> 8 & 0xff, lo & 0xff];
    }
  }, {
    key: "toSigned",
    value: function toSigned() {
      if (!this.unsigned) return this;
      return Long.fromBits(this.low, this.high, false);
    }
  }, {
    key: "toString",
    value: function toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix) throw new BSONError('radix');
      if (this.isZero()) return '0';
      if (this.isNegative()) {
        if (this.eq(Long.MIN_VALUE)) {
          var radixLong = Long.fromNumber(radix),
            div = this.div(radixLong),
            rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else return '-' + this.neg().toString(radix);
      }
      var radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned);
      var rem = this;
      var result = '';
      while (true) {
        var remDiv = rem.div(radixToPower);
        var intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;
        var digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6) digits = '0' + digits;
          result = '' + digits + result;
        }
      }
    }
  }, {
    key: "toUnsigned",
    value: function toUnsigned() {
      if (this.unsigned) return this;
      return Long.fromBits(this.low, this.high, true);
    }
  }, {
    key: "xor",
    value: function xor(other) {
      if (!Long.isLong(other)) other = Long.fromValue(other);
      return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    }
  }, {
    key: "eqz",
    value: function eqz() {
      return this.isZero();
    }
  }, {
    key: "le",
    value: function le(other) {
      return this.lessThanOrEqual(other);
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON(options) {
      if (options && options.relaxed) return this.toNumber();
      return {
        $numberLong: this.toString()
      };
    }
  }, {
    key: "inspect",
    value: function inspect(depth, options, _inspect9) {
      var _inspect10;
      (_inspect10 = _inspect9) !== null && _inspect10 !== void 0 ? _inspect10 : _inspect9 = defaultInspect;
      var longVal = _inspect9(this.toString(), options);
      var unsignedVal = this.unsigned ? ", ".concat(_inspect9(this.unsigned, options)) : '';
      return "new Long(".concat(longVal).concat(unsignedVal, ")");
    }
  }], [{
    key: "fromBits",
    value: function fromBits(lowBits, highBits, unsigned) {
      return new Long(lowBits, highBits, unsigned);
    }
  }, {
    key: "fromInt",
    value: function fromInt(value, unsigned) {
      var obj, cachedObj, cache;
      if (unsigned) {
        value >>>= 0;
        if (cache = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj) return cachedObj;
        }
        obj = Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache) UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache = -128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj) return cachedObj;
        }
        obj = Long.fromBits(value, value < 0 ? -1 : 0, false);
        if (cache) INT_CACHE[value] = obj;
        return obj;
      }
    }
  }, {
    key: "fromNumber",
    value: function fromNumber(value, unsigned) {
      if (isNaN(value)) return unsigned ? Long.UZERO : Long.ZERO;
      if (unsigned) {
        if (value < 0) return Long.UZERO;
        if (value >= TWO_PWR_64_DBL) return Long.MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL) return Long.MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL) return Long.MAX_VALUE;
      }
      if (value < 0) return Long.fromNumber(-value, unsigned).neg();
      return Long.fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }
  }, {
    key: "fromBigInt",
    value: function fromBigInt(value, unsigned) {
      var FROM_BIGINT_BIT_MASK = BigInt(0xffffffff);
      var FROM_BIGINT_BIT_SHIFT = BigInt(32);
      return new Long(Number(value & FROM_BIGINT_BIT_MASK), Number(value >> FROM_BIGINT_BIT_SHIFT & FROM_BIGINT_BIT_MASK), unsigned);
    }
  }, {
    key: "_fromString",
    value: function _fromString(str, unsigned, radix) {
      if (str.length === 0) throw new BSONError('empty string');
      if (radix < 2 || 36 < radix) throw new BSONError('radix');
      var p;
      if ((p = str.indexOf('-')) > 0) throw new BSONError('interior hyphen');else if (p === 0) {
        return Long._fromString(str.substring(1), unsigned, radix).neg();
      }
      var radixToPower = Long.fromNumber(Math.pow(radix, 8));
      var result = Long.ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
          value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = Long.fromNumber(Math.pow(radix, size));
          result = result.mul(power).add(Long.fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(Long.fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
  }, {
    key: "fromStringStrict",
    value: function fromStringStrict(str, unsignedOrRadix, radix) {
      var _radix2;
      var unsigned = false;
      if (typeof unsignedOrRadix === 'number') {
        radix = unsignedOrRadix, unsignedOrRadix = false;
      } else {
        unsigned = !!unsignedOrRadix;
      }
      (_radix2 = radix) !== null && _radix2 !== void 0 ? _radix2 : radix = 10;
      if (str.trim() !== str) {
        throw new BSONError("Input: '".concat(str, "' contains leading and/or trailing whitespace"));
      }
      if (!validateStringCharacters(str, radix)) {
        throw new BSONError("Input: '".concat(str, "' contains invalid characters for radix: ").concat(radix));
      }
      var cleanedStr = removeLeadingZerosAndExplicitPlus(str);
      var result = Long._fromString(cleanedStr, unsigned, radix);
      if (result.toString(radix).toLowerCase() !== cleanedStr.toLowerCase()) {
        throw new BSONError("Input: ".concat(str, " is not representable as ").concat(result.unsigned ? 'an unsigned' : 'a signed', " 64-bit Long ").concat(radix != null ? "with radix: ".concat(radix) : ''));
      }
      return result;
    }
  }, {
    key: "fromString",
    value: function fromString(str, unsignedOrRadix, radix) {
      var _radix3;
      var unsigned = false;
      if (typeof unsignedOrRadix === 'number') {
        radix = unsignedOrRadix, unsignedOrRadix = false;
      } else {
        unsigned = !!unsignedOrRadix;
      }
      (_radix3 = radix) !== null && _radix3 !== void 0 ? _radix3 : radix = 10;
      if (str === 'NaN' && radix < 24) {
        return Long.ZERO;
      } else if ((str === 'Infinity' || str === '+Infinity' || str === '-Infinity') && radix < 35) {
        return Long.ZERO;
      }
      return Long._fromString(str, unsigned, radix);
    }
  }, {
    key: "fromBytes",
    value: function fromBytes(bytes, unsigned, le) {
      return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
    }
  }, {
    key: "fromBytesLE",
    value: function fromBytesLE(bytes, unsigned) {
      return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
    }
  }, {
    key: "fromBytesBE",
    value: function fromBytesBE(bytes, unsigned) {
      return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
    }
  }, {
    key: "isLong",
    value: function isLong(value) {
      return value != null && _typeof(value) === 'object' && '__isLong__' in value && value.__isLong__ === true;
    }
  }, {
    key: "fromValue",
    value: function fromValue(val, unsigned) {
      if (typeof val === 'number') return Long.fromNumber(val, unsigned);
      if (typeof val === 'string') return Long.fromString(val, unsigned);
      return Long.fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
    }
  }, {
    key: "fromExtendedJSON",
    value: function fromExtendedJSON(doc, options) {
      var _options2 = _objectSpread({}, options),
        _options2$useBigInt = _options2.useBigInt64,
        useBigInt64 = _options2$useBigInt === void 0 ? false : _options2$useBigInt,
        _options2$relaxed = _options2.relaxed,
        relaxed = _options2$relaxed === void 0 ? true : _options2$relaxed;
      if (doc.$numberLong.length > MAX_INT64_STRING_LENGTH) {
        throw new BSONError('$numberLong string is too long');
      }
      if (!DECIMAL_REG_EX.test(doc.$numberLong)) {
        throw new BSONError("$numberLong string \"".concat(doc.$numberLong, "\" is in an invalid format"));
      }
      if (useBigInt64) {
        var bigIntResult = BigInt(doc.$numberLong);
        return BigInt.asIntN(64, bigIntResult);
      }
      var longResult = Long.fromString(doc.$numberLong);
      if (relaxed) {
        return longResult.toNumber();
      }
      return longResult;
    }
  }]);
}(BSONValue);
_Long.TWO_PWR_24 = _Long.fromInt(TWO_PWR_24_DBL);
_Long.MAX_UNSIGNED_VALUE = _Long.fromBits(0xffffffff | 0, 0xffffffff | 0, true);
_Long.ZERO = _Long.fromInt(0);
_Long.UZERO = _Long.fromInt(0, true);
_Long.ONE = _Long.fromInt(1);
_Long.UONE = _Long.fromInt(1, true);
_Long.NEG_ONE = _Long.fromInt(-1);
_Long.MAX_VALUE = _Long.fromBits(0xffffffff | 0, 0x7fffffff | 0, false);
_Long.MIN_VALUE = _Long.fromBits(0, 0x80000000 | 0, false);
var PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
var PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
var PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
var EXPONENT_MAX = 6111;
var EXPONENT_MIN = -6176;
var EXPONENT_BIAS = 6176;
var MAX_DIGITS = 34;
var NAN_BUFFER = ByteUtils.fromNumberArray([0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00].reverse());
var INF_NEGATIVE_BUFFER = ByteUtils.fromNumberArray([0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00].reverse());
var INF_POSITIVE_BUFFER = ByteUtils.fromNumberArray([0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00].reverse());
var EXPONENT_REGEX = /^([-+])?(\d+)?$/;
var COMBINATION_MASK = 0x1f;
var EXPONENT_MASK = 0x3fff;
var COMBINATION_INFINITY = 30;
var COMBINATION_NAN = 31;
function isDigit(value) {
  return !isNaN(parseInt(value, 10));
}
function divideu128(value) {
  var DIVISOR = _Long.fromNumber(1000 * 1000 * 1000);
  var _rem = _Long.fromNumber(0);
  if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {
    return {
      quotient: value,
      rem: _rem
    };
  }
  for (var i = 0; i <= 3; i++) {
    _rem = _rem.shiftLeft(32);
    _rem = _rem.add(new _Long(value.parts[i], 0));
    value.parts[i] = _rem.div(DIVISOR).low;
    _rem = _rem.modulo(DIVISOR);
  }
  return {
    quotient: value,
    rem: _rem
  };
}
function multiply64x2(left, right) {
  if (!left && !right) {
    return {
      high: _Long.fromNumber(0),
      low: _Long.fromNumber(0)
    };
  }
  var leftHigh = left.shiftRightUnsigned(32);
  var leftLow = new _Long(left.getLowBits(), 0);
  var rightHigh = right.shiftRightUnsigned(32);
  var rightLow = new _Long(right.getLowBits(), 0);
  var productHigh = leftHigh.multiply(rightHigh);
  var productMid = leftHigh.multiply(rightLow);
  var productMid2 = leftLow.multiply(rightHigh);
  var productLow = leftLow.multiply(rightLow);
  productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
  productMid = new _Long(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));
  productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
  productLow = productMid.shiftLeft(32).add(new _Long(productLow.getLowBits(), 0));
  return {
    high: productHigh,
    low: productLow
  };
}
function lessThan(left, right) {
  var uhleft = left.high >>> 0;
  var uhright = right.high >>> 0;
  if (uhleft < uhright) {
    return true;
  } else if (uhleft === uhright) {
    var ulleft = left.low >>> 0;
    var ulright = right.low >>> 0;
    if (ulleft < ulright) return true;
  }
  return false;
}
function invalidErr(string, message) {
  throw new BSONError("\"".concat(string, "\" is not a valid Decimal128 string - ").concat(message));
}
var _Decimal = exports.Decimal128 = /*#__PURE__*/function (_BSONValue5) {
  function Decimal128(bytes) {
    var _this6;
    _classCallCheck(this, Decimal128);
    _this6 = _callSuper(this, Decimal128);
    if (typeof bytes === 'string') {
      _this6.bytes = Decimal128.fromString(bytes).bytes;
    } else if (isUint8Array(bytes)) {
      if (bytes.byteLength !== 16) {
        throw new BSONError('Decimal128 must take a Buffer of 16 bytes');
      }
      _this6.bytes = bytes;
    } else {
      throw new BSONError('Decimal128 must take a Buffer or string');
    }
    return _this6;
  }
  _inherits(Decimal128, _BSONValue5);
  return _createClass(Decimal128, [{
    key: "_bsontype",
    get: function get() {
      return 'Decimal128';
    }
  }, {
    key: "toString",
    value: function toString() {
      var biased_exponent;
      var significand_digits = 0;
      var significand = new Array(36);
      for (var i = 0; i < significand.length; i++) significand[i] = 0;
      var index = 0;
      var is_zero = false;
      var significand_msb;
      var significand128 = {
        parts: [0, 0, 0, 0]
      };
      var j, k;
      var string = [];
      index = 0;
      var buffer = this.bytes;
      var low = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      var midl = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      var midh = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      var high = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      index = 0;
      var dec = {
        low: new _Long(low, midl),
        high: new _Long(midh, high)
      };
      if (dec.high.lessThan(_Long.ZERO)) {
        string.push('-');
      }
      var combination = high >> 26 & COMBINATION_MASK;
      if (combination >> 3 === 3) {
        if (combination === COMBINATION_INFINITY) {
          return string.join('') + 'Infinity';
        } else if (combination === COMBINATION_NAN) {
          return 'NaN';
        } else {
          biased_exponent = high >> 15 & EXPONENT_MASK;
          significand_msb = 0x08 + (high >> 14 & 0x01);
        }
      } else {
        significand_msb = high >> 14 & 0x07;
        biased_exponent = high >> 17 & EXPONENT_MASK;
      }
      var exponent = biased_exponent - EXPONENT_BIAS;
      significand128.parts[0] = (high & 0x3fff) + ((significand_msb & 0xf) << 14);
      significand128.parts[1] = midh;
      significand128.parts[2] = midl;
      significand128.parts[3] = low;
      if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {
        is_zero = true;
      } else {
        for (k = 3; k >= 0; k--) {
          var least_digits = 0;
          var result = divideu128(significand128);
          significand128 = result.quotient;
          least_digits = result.rem.low;
          if (!least_digits) continue;
          for (j = 8; j >= 0; j--) {
            significand[k * 9 + j] = least_digits % 10;
            least_digits = Math.floor(least_digits / 10);
          }
        }
      }
      if (is_zero) {
        significand_digits = 1;
        significand[index] = 0;
      } else {
        significand_digits = 36;
        while (!significand[index]) {
          significand_digits = significand_digits - 1;
          index = index + 1;
        }
      }
      var scientific_exponent = significand_digits - 1 + exponent;
      if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
        if (significand_digits > 34) {
          string.push("".concat(0));
          if (exponent > 0) string.push("E+".concat(exponent));else if (exponent < 0) string.push("E".concat(exponent));
          return string.join('');
        }
        string.push("".concat(significand[index++]));
        significand_digits = significand_digits - 1;
        if (significand_digits) {
          string.push('.');
        }
        for (var _i = 0; _i < significand_digits; _i++) {
          string.push("".concat(significand[index++]));
        }
        string.push('E');
        if (scientific_exponent > 0) {
          string.push("+".concat(scientific_exponent));
        } else {
          string.push("".concat(scientific_exponent));
        }
      } else {
        if (exponent >= 0) {
          for (var _i2 = 0; _i2 < significand_digits; _i2++) {
            string.push("".concat(significand[index++]));
          }
        } else {
          var radix_position = significand_digits + exponent;
          if (radix_position > 0) {
            for (var _i3 = 0; _i3 < radix_position; _i3++) {
              string.push("".concat(significand[index++]));
            }
          } else {
            string.push('0');
          }
          string.push('.');
          while (radix_position++ < 0) {
            string.push('0');
          }
          for (var _i4 = 0; _i4 < significand_digits - Math.max(radix_position - 1, 0); _i4++) {
            string.push("".concat(significand[index++]));
          }
        }
      }
      return string.join('');
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        $numberDecimal: this.toString()
      };
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON() {
      return {
        $numberDecimal: this.toString()
      };
    }
  }, {
    key: "inspect",
    value: function inspect(depth, options, _inspect11) {
      var _inspect12;
      (_inspect12 = _inspect11) !== null && _inspect12 !== void 0 ? _inspect12 : _inspect11 = defaultInspect;
      var d128string = _inspect11(this.toString(), options);
      return "new Decimal128(".concat(d128string, ")");
    }
  }], [{
    key: "fromString",
    value: function fromString(representation) {
      return Decimal128._fromString(representation, {
        allowRounding: false
      });
    }
  }, {
    key: "fromStringWithRounding",
    value: function fromStringWithRounding(representation) {
      return Decimal128._fromString(representation, {
        allowRounding: true
      });
    }
  }, {
    key: "_fromString",
    value: function _fromString(representation, options) {
      var isNegative = false;
      var sawSign = false;
      var sawRadix = false;
      var foundNonZero = false;
      var significantDigits = 0;
      var nDigitsRead = 0;
      var nDigits = 0;
      var radixPosition = 0;
      var firstNonZero = 0;
      var digits = [0];
      var nDigitsStored = 0;
      var digitsInsert = 0;
      var lastDigit = 0;
      var exponent = 0;
      var significandHigh = new _Long(0, 0);
      var significandLow = new _Long(0, 0);
      var biasedExponent = 0;
      var index = 0;
      if (representation.length >= 7000) {
        throw new BSONError('' + representation + ' not a valid Decimal128 string');
      }
      var stringMatch = representation.match(PARSE_STRING_REGEXP);
      var infMatch = representation.match(PARSE_INF_REGEXP);
      var nanMatch = representation.match(PARSE_NAN_REGEXP);
      if (!stringMatch && !infMatch && !nanMatch || representation.length === 0) {
        throw new BSONError('' + representation + ' not a valid Decimal128 string');
      }
      if (stringMatch) {
        var unsignedNumber = stringMatch[2];
        var _e = stringMatch[4];
        var expSign = stringMatch[5];
        var expNumber = stringMatch[6];
        if (_e && expNumber === undefined) invalidErr(representation, 'missing exponent power');
        if (_e && unsignedNumber === undefined) invalidErr(representation, 'missing exponent base');
        if (_e === undefined && (expSign || expNumber)) {
          invalidErr(representation, 'missing e before exponent');
        }
      }
      if (representation[index] === '+' || representation[index] === '-') {
        sawSign = true;
        isNegative = representation[index++] === '-';
      }
      if (!isDigit(representation[index]) && representation[index] !== '.') {
        if (representation[index] === 'i' || representation[index] === 'I') {
          return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
        } else if (representation[index] === 'N') {
          return new Decimal128(NAN_BUFFER);
        }
      }
      while (isDigit(representation[index]) || representation[index] === '.') {
        if (representation[index] === '.') {
          if (sawRadix) invalidErr(representation, 'contains multiple periods');
          sawRadix = true;
          index = index + 1;
          continue;
        }
        if (nDigitsStored < MAX_DIGITS) {
          if (representation[index] !== '0' || foundNonZero) {
            if (!foundNonZero) {
              firstNonZero = nDigitsRead;
            }
            foundNonZero = true;
            digits[digitsInsert++] = parseInt(representation[index], 10);
            nDigitsStored = nDigitsStored + 1;
          }
        }
        if (foundNonZero) nDigits = nDigits + 1;
        if (sawRadix) radixPosition = radixPosition + 1;
        nDigitsRead = nDigitsRead + 1;
        index = index + 1;
      }
      if (sawRadix && !nDigitsRead) throw new BSONError('' + representation + ' not a valid Decimal128 string');
      if (representation[index] === 'e' || representation[index] === 'E') {
        var match = representation.substr(++index).match(EXPONENT_REGEX);
        if (!match || !match[2]) return new Decimal128(NAN_BUFFER);
        exponent = parseInt(match[0], 10);
        index = index + match[0].length;
      }
      if (representation[index]) return new Decimal128(NAN_BUFFER);
      if (!nDigitsStored) {
        digits[0] = 0;
        nDigits = 1;
        nDigitsStored = 1;
        significantDigits = 0;
      } else {
        lastDigit = nDigitsStored - 1;
        significantDigits = nDigits;
        if (significantDigits !== 1) {
          while (representation[firstNonZero + significantDigits - 1 + Number(sawSign) + Number(sawRadix)] === '0') {
            significantDigits = significantDigits - 1;
          }
        }
      }
      if (exponent <= radixPosition && radixPosition > exponent + (1 << 14)) {
        exponent = EXPONENT_MIN;
      } else {
        exponent = exponent - radixPosition;
      }
      while (exponent > EXPONENT_MAX) {
        lastDigit = lastDigit + 1;
        if (lastDigit >= MAX_DIGITS) {
          if (significantDigits === 0) {
            exponent = EXPONENT_MAX;
            break;
          }
          invalidErr(representation, 'overflow');
        }
        exponent = exponent - 1;
      }
      if (options.allowRounding) {
        while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
          if (lastDigit === 0 && significantDigits < nDigitsStored) {
            exponent = EXPONENT_MIN;
            significantDigits = 0;
            break;
          }
          if (nDigitsStored < nDigits) {
            nDigits = nDigits - 1;
          } else {
            lastDigit = lastDigit - 1;
          }
          if (exponent < EXPONENT_MAX) {
            exponent = exponent + 1;
          } else {
            var digitsString = digits.join('');
            if (digitsString.match(/^0+$/)) {
              exponent = EXPONENT_MAX;
              break;
            }
            invalidErr(representation, 'overflow');
          }
        }
        if (lastDigit + 1 < significantDigits) {
          var endOfString = nDigitsRead;
          if (sawRadix) {
            firstNonZero = firstNonZero + 1;
            endOfString = endOfString + 1;
          }
          if (sawSign) {
            firstNonZero = firstNonZero + 1;
            endOfString = endOfString + 1;
          }
          var roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
          var roundBit = 0;
          if (roundDigit >= 5) {
            roundBit = 1;
            if (roundDigit === 5) {
              roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;
              for (var i = firstNonZero + lastDigit + 2; i < endOfString; i++) {
                if (parseInt(representation[i], 10)) {
                  roundBit = 1;
                  break;
                }
              }
            }
          }
          if (roundBit) {
            var dIdx = lastDigit;
            for (; dIdx >= 0; dIdx--) {
              if (++digits[dIdx] > 9) {
                digits[dIdx] = 0;
                if (dIdx === 0) {
                  if (exponent < EXPONENT_MAX) {
                    exponent = exponent + 1;
                    digits[dIdx] = 1;
                  } else {
                    return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
                  }
                }
              } else {
                break;
              }
            }
          }
        }
      } else {
        while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
          if (lastDigit === 0) {
            if (significantDigits === 0) {
              exponent = EXPONENT_MIN;
              break;
            }
            invalidErr(representation, 'exponent underflow');
          }
          if (nDigitsStored < nDigits) {
            if (representation[nDigits - 1 + Number(sawSign) + Number(sawRadix)] !== '0' && significantDigits !== 0) {
              invalidErr(representation, 'inexact rounding');
            }
            nDigits = nDigits - 1;
          } else {
            if (digits[lastDigit] !== 0) {
              invalidErr(representation, 'inexact rounding');
            }
            lastDigit = lastDigit - 1;
          }
          if (exponent < EXPONENT_MAX) {
            exponent = exponent + 1;
          } else {
            invalidErr(representation, 'overflow');
          }
        }
        if (lastDigit + 1 < significantDigits) {
          if (sawRadix) {
            firstNonZero = firstNonZero + 1;
          }
          if (sawSign) {
            firstNonZero = firstNonZero + 1;
          }
          var _roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
          if (_roundDigit !== 0) {
            invalidErr(representation, 'inexact rounding');
          }
        }
      }
      significandHigh = _Long.fromNumber(0);
      significandLow = _Long.fromNumber(0);
      if (significantDigits === 0) {
        significandHigh = _Long.fromNumber(0);
        significandLow = _Long.fromNumber(0);
      } else if (lastDigit < 17) {
        var _dIdx = 0;
        significandLow = _Long.fromNumber(digits[_dIdx++]);
        significandHigh = new _Long(0, 0);
        for (; _dIdx <= lastDigit; _dIdx++) {
          significandLow = significandLow.multiply(_Long.fromNumber(10));
          significandLow = significandLow.add(_Long.fromNumber(digits[_dIdx]));
        }
      } else {
        var _dIdx2 = 0;
        significandHigh = _Long.fromNumber(digits[_dIdx2++]);
        for (; _dIdx2 <= lastDigit - 17; _dIdx2++) {
          significandHigh = significandHigh.multiply(_Long.fromNumber(10));
          significandHigh = significandHigh.add(_Long.fromNumber(digits[_dIdx2]));
        }
        significandLow = _Long.fromNumber(digits[_dIdx2++]);
        for (; _dIdx2 <= lastDigit; _dIdx2++) {
          significandLow = significandLow.multiply(_Long.fromNumber(10));
          significandLow = significandLow.add(_Long.fromNumber(digits[_dIdx2]));
        }
      }
      var significand = multiply64x2(significandHigh, _Long.fromString('100000000000000000'));
      significand.low = significand.low.add(significandLow);
      if (lessThan(significand.low, significandLow)) {
        significand.high = significand.high.add(_Long.fromNumber(1));
      }
      biasedExponent = exponent + EXPONENT_BIAS;
      var dec = {
        low: _Long.fromNumber(0),
        high: _Long.fromNumber(0)
      };
      if (significand.high.shiftRightUnsigned(49).and(_Long.fromNumber(1)).equals(_Long.fromNumber(1))) {
        dec.high = dec.high.or(_Long.fromNumber(0x3).shiftLeft(61));
        dec.high = dec.high.or(_Long.fromNumber(biasedExponent).and(_Long.fromNumber(0x3fff).shiftLeft(47)));
        dec.high = dec.high.or(significand.high.and(_Long.fromNumber(0x7fffffffffff)));
      } else {
        dec.high = dec.high.or(_Long.fromNumber(biasedExponent & 0x3fff).shiftLeft(49));
        dec.high = dec.high.or(significand.high.and(_Long.fromNumber(0x1ffffffffffff)));
      }
      dec.low = significand.low;
      if (isNegative) {
        dec.high = dec.high.or(_Long.fromString('9223372036854775808'));
      }
      var buffer = ByteUtils.allocateUnsafe(16);
      index = 0;
      buffer[index++] = dec.low.low & 0xff;
      buffer[index++] = dec.low.low >> 8 & 0xff;
      buffer[index++] = dec.low.low >> 16 & 0xff;
      buffer[index++] = dec.low.low >> 24 & 0xff;
      buffer[index++] = dec.low.high & 0xff;
      buffer[index++] = dec.low.high >> 8 & 0xff;
      buffer[index++] = dec.low.high >> 16 & 0xff;
      buffer[index++] = dec.low.high >> 24 & 0xff;
      buffer[index++] = dec.high.low & 0xff;
      buffer[index++] = dec.high.low >> 8 & 0xff;
      buffer[index++] = dec.high.low >> 16 & 0xff;
      buffer[index++] = dec.high.low >> 24 & 0xff;
      buffer[index++] = dec.high.high & 0xff;
      buffer[index++] = dec.high.high >> 8 & 0xff;
      buffer[index++] = dec.high.high >> 16 & 0xff;
      buffer[index++] = dec.high.high >> 24 & 0xff;
      return new Decimal128(buffer);
    }
  }, {
    key: "fromExtendedJSON",
    value: function fromExtendedJSON(doc) {
      return Decimal128.fromString(doc.$numberDecimal);
    }
  }]);
}(BSONValue);
var _Double = exports.Double = /*#__PURE__*/function (_BSONValue6) {
  function Double(value) {
    var _this7;
    _classCallCheck(this, Double);
    _this7 = _callSuper(this, Double);
    if (value instanceof Number) {
      value = value.valueOf();
    }
    _this7.value = +value;
    return _this7;
  }
  _inherits(Double, _BSONValue6);
  return _createClass(Double, [{
    key: "_bsontype",
    get: function get() {
      return 'Double';
    }
  }, {
    key: "valueOf",
    value: function valueOf() {
      return this.value;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.value;
    }
  }, {
    key: "toString",
    value: function toString(radix) {
      return this.value.toString(radix);
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON(options) {
      if (options && (options.legacy || options.relaxed && isFinite(this.value))) {
        return this.value;
      }
      if (Object.is(Math.sign(this.value), -0)) {
        return {
          $numberDouble: '-0.0'
        };
      }
      return {
        $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()
      };
    }
  }, {
    key: "inspect",
    value: function inspect(depth, options, _inspect13) {
      var _inspect14;
      (_inspect14 = _inspect13) !== null && _inspect14 !== void 0 ? _inspect14 : _inspect13 = defaultInspect;
      return "new Double(".concat(_inspect13(this.value, options), ")");
    }
  }], [{
    key: "fromString",
    value: function fromString(value) {
      var coercedValue = Number(value);
      if (value === 'NaN') return new Double(NaN);
      if (value === 'Infinity') return new Double(Infinity);
      if (value === '-Infinity') return new Double(-Infinity);
      if (!Number.isFinite(coercedValue)) {
        throw new BSONError("Input: ".concat(value, " is not representable as a Double"));
      }
      if (value.trim() !== value) {
        throw new BSONError("Input: '".concat(value, "' contains whitespace"));
      }
      if (value === '') {
        throw new BSONError("Input is an empty string");
      }
      if (/[^-0-9.+eE]/.test(value)) {
        throw new BSONError("Input: '".concat(value, "' is not in decimal or exponential notation"));
      }
      return new Double(coercedValue);
    }
  }, {
    key: "fromExtendedJSON",
    value: function fromExtendedJSON(doc, options) {
      var doubleValue = parseFloat(doc.$numberDouble);
      return options && options.relaxed ? doubleValue : new Double(doubleValue);
    }
  }]);
}(BSONValue);
var _Int = exports.Int32 = /*#__PURE__*/function (_BSONValue7) {
  function Int32(value) {
    var _this8;
    _classCallCheck(this, Int32);
    _this8 = _callSuper(this, Int32);
    if (value instanceof Number) {
      value = value.valueOf();
    }
    _this8.value = +value | 0;
    return _this8;
  }
  _inherits(Int32, _BSONValue7);
  return _createClass(Int32, [{
    key: "_bsontype",
    get: function get() {
      return 'Int32';
    }
  }, {
    key: "valueOf",
    value: function valueOf() {
      return this.value;
    }
  }, {
    key: "toString",
    value: function toString(radix) {
      return this.value.toString(radix);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.value;
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON(options) {
      if (options && (options.relaxed || options.legacy)) return this.value;
      return {
        $numberInt: this.value.toString()
      };
    }
  }, {
    key: "inspect",
    value: function inspect(depth, options, _inspect15) {
      var _inspect16;
      (_inspect16 = _inspect15) !== null && _inspect16 !== void 0 ? _inspect16 : _inspect15 = defaultInspect;
      return "new Int32(".concat(_inspect15(this.value, options), ")");
    }
  }], [{
    key: "fromString",
    value: function fromString(value) {
      var cleanedValue = removeLeadingZerosAndExplicitPlus(value);
      var coercedValue = Number(value);
      if (BSON_INT32_MAX < coercedValue) {
        throw new BSONError("Input: '".concat(value, "' is larger than the maximum value for Int32"));
      } else if (BSON_INT32_MIN > coercedValue) {
        throw new BSONError("Input: '".concat(value, "' is smaller than the minimum value for Int32"));
      } else if (!Number.isSafeInteger(coercedValue)) {
        throw new BSONError("Input: '".concat(value, "' is not a safe integer"));
      } else if (coercedValue.toString() !== cleanedValue) {
        throw new BSONError("Input: '".concat(value, "' is not a valid Int32 string"));
      }
      return new Int32(coercedValue);
    }
  }, {
    key: "fromExtendedJSON",
    value: function fromExtendedJSON(doc, options) {
      return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int32(doc.$numberInt);
    }
  }]);
}(BSONValue);
var _MaxKey = exports.MaxKey = /*#__PURE__*/function (_BSONValue8) {
  function MaxKey() {
    _classCallCheck(this, MaxKey);
    return _callSuper(this, MaxKey, arguments);
  }
  _inherits(MaxKey, _BSONValue8);
  return _createClass(MaxKey, [{
    key: "_bsontype",
    get: function get() {
      return 'MaxKey';
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON() {
      return {
        $maxKey: 1
      };
    }
  }, {
    key: "inspect",
    value: function inspect() {
      return 'new MaxKey()';
    }
  }], [{
    key: "fromExtendedJSON",
    value: function fromExtendedJSON() {
      return new MaxKey();
    }
  }]);
}(BSONValue);
var _MinKey = exports.MinKey = /*#__PURE__*/function (_BSONValue9) {
  function MinKey() {
    _classCallCheck(this, MinKey);
    return _callSuper(this, MinKey, arguments);
  }
  _inherits(MinKey, _BSONValue9);
  return _createClass(MinKey, [{
    key: "_bsontype",
    get: function get() {
      return 'MinKey';
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON() {
      return {
        $minKey: 1
      };
    }
  }, {
    key: "inspect",
    value: function inspect() {
      return 'new MinKey()';
    }
  }], [{
    key: "fromExtendedJSON",
    value: function fromExtendedJSON() {
      return new MinKey();
    }
  }]);
}(BSONValue);
var FLOAT = new Float64Array(1);
var FLOAT_BYTES = new Uint8Array(FLOAT.buffer, 0, 8);
FLOAT[0] = -1;
var isBigEndian = FLOAT_BYTES[7] === 0;
var NumberUtils = {
  getNonnegativeInt32LE: function getNonnegativeInt32LE(source, offset) {
    if (source[offset + 3] > 127) {
      throw new RangeError("Size cannot be negative at offset: ".concat(offset));
    }
    return source[offset] | source[offset + 1] << 8 | source[offset + 2] << 16 | source[offset + 3] << 24;
  },
  getInt32LE: function getInt32LE(source, offset) {
    return source[offset] | source[offset + 1] << 8 | source[offset + 2] << 16 | source[offset + 3] << 24;
  },
  getUint32LE: function getUint32LE(source, offset) {
    return source[offset] + source[offset + 1] * 256 + source[offset + 2] * 65536 + source[offset + 3] * 16777216;
  },
  getUint32BE: function getUint32BE(source, offset) {
    return source[offset + 3] + source[offset + 2] * 256 + source[offset + 1] * 65536 + source[offset] * 16777216;
  },
  getBigInt64LE: function getBigInt64LE(source, offset) {
    var lo = NumberUtils.getUint32LE(source, offset);
    var hi = NumberUtils.getUint32LE(source, offset + 4);
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  },
  getFloat64LE: isBigEndian ? function (source, offset) {
    FLOAT_BYTES[7] = source[offset];
    FLOAT_BYTES[6] = source[offset + 1];
    FLOAT_BYTES[5] = source[offset + 2];
    FLOAT_BYTES[4] = source[offset + 3];
    FLOAT_BYTES[3] = source[offset + 4];
    FLOAT_BYTES[2] = source[offset + 5];
    FLOAT_BYTES[1] = source[offset + 6];
    FLOAT_BYTES[0] = source[offset + 7];
    return FLOAT[0];
  } : function (source, offset) {
    FLOAT_BYTES[0] = source[offset];
    FLOAT_BYTES[1] = source[offset + 1];
    FLOAT_BYTES[2] = source[offset + 2];
    FLOAT_BYTES[3] = source[offset + 3];
    FLOAT_BYTES[4] = source[offset + 4];
    FLOAT_BYTES[5] = source[offset + 5];
    FLOAT_BYTES[6] = source[offset + 6];
    FLOAT_BYTES[7] = source[offset + 7];
    return FLOAT[0];
  },
  setInt32BE: function setInt32BE(destination, offset, value) {
    destination[offset + 3] = value;
    value >>>= 8;
    destination[offset + 2] = value;
    value >>>= 8;
    destination[offset + 1] = value;
    value >>>= 8;
    destination[offset] = value;
    return 4;
  },
  setInt32LE: function setInt32LE(destination, offset, value) {
    destination[offset] = value;
    value >>>= 8;
    destination[offset + 1] = value;
    value >>>= 8;
    destination[offset + 2] = value;
    value >>>= 8;
    destination[offset + 3] = value;
    return 4;
  },
  setBigInt64LE: function setBigInt64LE(destination, offset, value) {
    var mask32bits = BigInt(4294967295);
    var lo = Number(value & mask32bits);
    destination[offset] = lo;
    lo >>= 8;
    destination[offset + 1] = lo;
    lo >>= 8;
    destination[offset + 2] = lo;
    lo >>= 8;
    destination[offset + 3] = lo;
    var hi = Number(value >> BigInt(32) & mask32bits);
    destination[offset + 4] = hi;
    hi >>= 8;
    destination[offset + 5] = hi;
    hi >>= 8;
    destination[offset + 6] = hi;
    hi >>= 8;
    destination[offset + 7] = hi;
    return 8;
  },
  setFloat64LE: isBigEndian ? function (destination, offset, value) {
    FLOAT[0] = value;
    destination[offset] = FLOAT_BYTES[7];
    destination[offset + 1] = FLOAT_BYTES[6];
    destination[offset + 2] = FLOAT_BYTES[5];
    destination[offset + 3] = FLOAT_BYTES[4];
    destination[offset + 4] = FLOAT_BYTES[3];
    destination[offset + 5] = FLOAT_BYTES[2];
    destination[offset + 6] = FLOAT_BYTES[1];
    destination[offset + 7] = FLOAT_BYTES[0];
    return 8;
  } : function (destination, offset, value) {
    FLOAT[0] = value;
    destination[offset] = FLOAT_BYTES[0];
    destination[offset + 1] = FLOAT_BYTES[1];
    destination[offset + 2] = FLOAT_BYTES[2];
    destination[offset + 3] = FLOAT_BYTES[3];
    destination[offset + 4] = FLOAT_BYTES[4];
    destination[offset + 5] = FLOAT_BYTES[5];
    destination[offset + 6] = FLOAT_BYTES[6];
    destination[offset + 7] = FLOAT_BYTES[7];
    return 8;
  }
};
var checkForHexRegExp = new RegExp('^[0-9a-fA-F]{24}$');
var PROCESS_UNIQUE = null;
var _ObjectId = exports.ObjectId = /*#__PURE__*/function (_BSONValue10) {
  function ObjectId(inputId) {
    var _this9;
    _classCallCheck(this, ObjectId);
    _this9 = _callSuper(this, ObjectId);
    var workingId;
    if (_typeof(inputId) === 'object' && inputId && 'id' in inputId) {
      if (typeof inputId.id !== 'string' && !ArrayBuffer.isView(inputId.id)) {
        throw new BSONError('Argument passed in must have an id that is of type string or Buffer');
      }
      if ('toHexString' in inputId && typeof inputId.toHexString === 'function') {
        workingId = ByteUtils.fromHex(inputId.toHexString());
      } else {
        workingId = inputId.id;
      }
    } else {
      workingId = inputId;
    }
    if (workingId == null || typeof workingId === 'number') {
      _this9.buffer = ObjectId.generate(typeof workingId === 'number' ? workingId : undefined);
    } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {
      _this9.buffer = ByteUtils.toLocalBufferType(workingId);
    } else if (typeof workingId === 'string') {
      if (workingId.length === 24 && checkForHexRegExp.test(workingId)) {
        _this9.buffer = ByteUtils.fromHex(workingId);
      } else {
        throw new BSONError('input must be a 24 character hex string, 12 byte Uint8Array, or an integer');
      }
    } else {
      throw new BSONError('Argument passed in does not match the accepted types');
    }
    if (ObjectId.cacheHexString) {
      _this9.__id = ByteUtils.toHex(_this9.id);
    }
    return _this9;
  }
  _inherits(ObjectId, _BSONValue10);
  return _createClass(ObjectId, [{
    key: "_bsontype",
    get: function get() {
      return 'ObjectId';
    }
  }, {
    key: "id",
    get: function get() {
      return this.buffer;
    },
    set: function set(value) {
      this.buffer = value;
      if (ObjectId.cacheHexString) {
        this.__id = ByteUtils.toHex(value);
      }
    }
  }, {
    key: "toHexString",
    value: function toHexString() {
      if (ObjectId.cacheHexString && this.__id) {
        return this.__id;
      }
      var hexString = ByteUtils.toHex(this.id);
      if (ObjectId.cacheHexString && !this.__id) {
        this.__id = hexString;
      }
      return hexString;
    }
  }, {
    key: "toString",
    value: function toString(encoding) {
      if (encoding === 'base64') return ByteUtils.toBase64(this.id);
      if (encoding === 'hex') return this.toHexString();
      return this.toHexString();
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.toHexString();
    }
  }, {
    key: "equals",
    value: function equals(otherId) {
      if (otherId === undefined || otherId === null) {
        return false;
      }
      if (ObjectId.is(otherId)) {
        return this.buffer[11] === otherId.buffer[11] && ByteUtils.equals(this.buffer, otherId.buffer);
      }
      if (typeof otherId === 'string') {
        return otherId.toLowerCase() === this.toHexString();
      }
      if (_typeof(otherId) === 'object' && typeof otherId.toHexString === 'function') {
        var otherIdString = otherId.toHexString();
        var thisIdString = this.toHexString();
        return typeof otherIdString === 'string' && otherIdString.toLowerCase() === thisIdString;
      }
      return false;
    }
  }, {
    key: "getTimestamp",
    value: function getTimestamp() {
      var timestamp = new Date();
      var time = NumberUtils.getUint32BE(this.buffer, 0);
      timestamp.setTime(Math.floor(time) * 1000);
      return timestamp;
    }
  }, {
    key: "serializeInto",
    value: function serializeInto(uint8array, index) {
      uint8array[index] = this.buffer[0];
      uint8array[index + 1] = this.buffer[1];
      uint8array[index + 2] = this.buffer[2];
      uint8array[index + 3] = this.buffer[3];
      uint8array[index + 4] = this.buffer[4];
      uint8array[index + 5] = this.buffer[5];
      uint8array[index + 6] = this.buffer[6];
      uint8array[index + 7] = this.buffer[7];
      uint8array[index + 8] = this.buffer[8];
      uint8array[index + 9] = this.buffer[9];
      uint8array[index + 10] = this.buffer[10];
      uint8array[index + 11] = this.buffer[11];
      return 12;
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON() {
      if (this.toHexString) return {
        $oid: this.toHexString()
      };
      return {
        $oid: this.toString('hex')
      };
    }
  }, {
    key: "inspect",
    value: function inspect(depth, options, _inspect17) {
      var _inspect18;
      (_inspect18 = _inspect17) !== null && _inspect18 !== void 0 ? _inspect18 : _inspect17 = defaultInspect;
      return "new ObjectId(".concat(_inspect17(this.toHexString(), options), ")");
    }
  }], [{
    key: "getInc",
    value: function getInc() {
      return ObjectId.index = (ObjectId.index + 1) % 0xffffff;
    }
  }, {
    key: "generate",
    value: function generate(time) {
      if ('number' !== typeof time) {
        time = Math.floor(Date.now() / 1000);
      }
      var inc = ObjectId.getInc();
      var buffer = ByteUtils.allocateUnsafe(12);
      NumberUtils.setInt32BE(buffer, 0, time);
      if (PROCESS_UNIQUE === null) {
        PROCESS_UNIQUE = ByteUtils.randomBytes(5);
      }
      buffer[4] = PROCESS_UNIQUE[0];
      buffer[5] = PROCESS_UNIQUE[1];
      buffer[6] = PROCESS_UNIQUE[2];
      buffer[7] = PROCESS_UNIQUE[3];
      buffer[8] = PROCESS_UNIQUE[4];
      buffer[11] = inc & 0xff;
      buffer[10] = inc >> 8 & 0xff;
      buffer[9] = inc >> 16 & 0xff;
      return buffer;
    }
  }, {
    key: "is",
    value: function is(variable) {
      return variable != null && _typeof(variable) === 'object' && '_bsontype' in variable && variable._bsontype === 'ObjectId';
    }
  }, {
    key: "createPk",
    value: function createPk() {
      return new ObjectId();
    }
  }, {
    key: "createFromTime",
    value: function createFromTime(time) {
      var buffer = ByteUtils.allocate(12);
      for (var i = 11; i >= 4; i--) buffer[i] = 0;
      NumberUtils.setInt32BE(buffer, 0, time);
      return new ObjectId(buffer);
    }
  }, {
    key: "createFromHexString",
    value: function createFromHexString(hexString) {
      if ((hexString === null || hexString === void 0 ? void 0 : hexString.length) !== 24) {
        throw new BSONError('hex string must be 24 characters');
      }
      return new ObjectId(ByteUtils.fromHex(hexString));
    }
  }, {
    key: "createFromBase64",
    value: function createFromBase64(base64) {
      if ((base64 === null || base64 === void 0 ? void 0 : base64.length) !== 16) {
        throw new BSONError('base64 string must be 16 characters');
      }
      return new ObjectId(ByteUtils.fromBase64(base64));
    }
  }, {
    key: "isValid",
    value: function isValid(id) {
      if (id == null) return false;
      try {
        new ObjectId(id);
        return true;
      } catch (_unused4) {
        return false;
      }
    }
  }, {
    key: "fromExtendedJSON",
    value: function fromExtendedJSON(doc) {
      return new ObjectId(doc.$oid);
    }
  }]);
}(BSONValue);
_ObjectId.index = Math.floor(Math.random() * 0xffffff);
function internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined) {
  var totalLength = 4 + 1;
  if (Array.isArray(object)) {
    for (var i = 0; i < object.length; i++) {
      totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);
    }
  } else {
    var _object;
    if (typeof ((_object = object) === null || _object === void 0 ? void 0 : _object.toBSON) === 'function') {
      object = object.toBSON();
    }
    for (var _i5 = 0, _Object$keys = Object.keys(object); _i5 < _Object$keys.length; _i5++) {
      var key = _Object$keys[_i5];
      totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);
    }
  }
  return totalLength;
}
function calculateElement(name, value) {
  var _value;
  var serializeFunctions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var ignoreUndefined = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  if (typeof ((_value = value) === null || _value === void 0 ? void 0 : _value.toBSON) === 'function') {
    value = value.toBSON();
  }
  switch (_typeof(value)) {
    case 'string':
      return 1 + ByteUtils.utf8ByteLength(name) + 1 + 4 + ByteUtils.utf8ByteLength(value) + 1;
    case 'number':
      if (Math.floor(value) === value && value >= JS_INT_MIN && value <= JS_INT_MAX) {
        if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (4 + 1);
        } else {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
        }
      } else {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
      }
    case 'undefined':
      if (isArray || !ignoreUndefined) return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
      return 0;
    case 'boolean':
      return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 1);
    case 'object':
      if (value != null && typeof value._bsontype === 'string' && value[Symbol["for"]('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {
        throw new BSONVersionError();
      } else if (value == null || value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
      } else if (value._bsontype === 'ObjectId') {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (12 + 1);
      } else if (value instanceof Date || isDate(value)) {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
      } else if (ArrayBuffer.isView(value) || value instanceof ArrayBuffer || isAnyArrayBuffer(value)) {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 4 + 1) + value.byteLength;
      } else if (value._bsontype === 'Long' || value._bsontype === 'Double' || value._bsontype === 'Timestamp') {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
      } else if (value._bsontype === 'Decimal128') {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (16 + 1);
      } else if (value._bsontype === 'Code') {
        if (value.scope != null && Object.keys(value.scope).length > 0) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1 + internalCalculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
        } else {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1;
        }
      } else if (value._bsontype === 'Binary') {
        var binary = value;
        if (binary.sub_type === _Binary2.SUBTYPE_BYTE_ARRAY) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1 + 4);
        } else {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1);
        }
      } else if (value._bsontype === 'Symbol') {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + ByteUtils.utf8ByteLength(value.value) + 4 + 1 + 1;
      } else if (value._bsontype === 'DBRef') {
        var ordered_values = Object.assign({
          $ref: value.collection,
          $id: value.oid
        }, value.fields);
        if (value.db != null) {
          ordered_values['$db'] = value.db;
        }
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + internalCalculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);
      } else if (value instanceof RegExp || isRegExp(value)) {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.source) + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
      } else if (value._bsontype === 'BSONRegExp') {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.pattern) + 1 + ByteUtils.utf8ByteLength(value.options) + 1;
      } else {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + internalCalculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;
      }
    case 'function':
      if (serializeFunctions) {
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.toString()) + 1;
      }
  }
  return 0;
}
function alphabetize(str) {
  return str.split('').sort().join('');
}
var _BSONRegExp = exports.BSONRegExp = /*#__PURE__*/function (_BSONValue11) {
  function BSONRegExp(pattern, options) {
    var _this10;
    _classCallCheck(this, BSONRegExp);
    _this10 = _callSuper(this, BSONRegExp);
    _this10.pattern = pattern;
    _this10.options = alphabetize(options !== null && options !== void 0 ? options : '');
    if (_this10.pattern.indexOf('\x00') !== -1) {
      throw new BSONError("BSON Regex patterns cannot contain null bytes, found: ".concat(JSON.stringify(_this10.pattern)));
    }
    if (_this10.options.indexOf('\x00') !== -1) {
      throw new BSONError("BSON Regex options cannot contain null bytes, found: ".concat(JSON.stringify(_this10.options)));
    }
    for (var i = 0; i < _this10.options.length; i++) {
      if (!(_this10.options[i] === 'i' || _this10.options[i] === 'm' || _this10.options[i] === 'x' || _this10.options[i] === 'l' || _this10.options[i] === 's' || _this10.options[i] === 'u')) {
        throw new BSONError("The regular expression option [".concat(_this10.options[i], "] is not supported"));
      }
    }
    return _this10;
  }
  _inherits(BSONRegExp, _BSONValue11);
  return _createClass(BSONRegExp, [{
    key: "_bsontype",
    get: function get() {
      return 'BSONRegExp';
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON(options) {
      options = options || {};
      if (options.legacy) {
        return {
          $regex: this.pattern,
          $options: this.options
        };
      }
      return {
        $regularExpression: {
          pattern: this.pattern,
          options: this.options
        }
      };
    }
  }, {
    key: "inspect",
    value: function inspect(depth, options, _inspect19) {
      var _getStylizeFunction, _inspect20;
      var stylize = (_getStylizeFunction = getStylizeFunction(options)) !== null && _getStylizeFunction !== void 0 ? _getStylizeFunction : function (v) {
        return v;
      };
      (_inspect20 = _inspect19) !== null && _inspect20 !== void 0 ? _inspect20 : _inspect19 = defaultInspect;
      var pattern = stylize(_inspect19(this.pattern), 'regexp');
      var flags = stylize(_inspect19(this.options), 'regexp');
      return "new BSONRegExp(".concat(pattern, ", ").concat(flags, ")");
    }
  }], [{
    key: "parseOptions",
    value: function parseOptions(options) {
      return options ? options.split('').sort().join('') : '';
    }
  }, {
    key: "fromExtendedJSON",
    value: function fromExtendedJSON(doc) {
      if ('$regex' in doc) {
        if (typeof doc.$regex !== 'string') {
          if (doc.$regex._bsontype === 'BSONRegExp') {
            return doc;
          }
        } else {
          return new BSONRegExp(doc.$regex, BSONRegExp.parseOptions(doc.$options));
        }
      }
      if ('$regularExpression' in doc) {
        return new BSONRegExp(doc.$regularExpression.pattern, BSONRegExp.parseOptions(doc.$regularExpression.options));
      }
      throw new BSONError("Unexpected BSONRegExp EJSON object form: ".concat(JSON.stringify(doc)));
    }
  }]);
}(BSONValue);
var _BSONSymbol = exports.BSONSymbol = /*#__PURE__*/function (_BSONValue12) {
  function BSONSymbol(value) {
    var _this11;
    _classCallCheck(this, BSONSymbol);
    _this11 = _callSuper(this, BSONSymbol);
    _this11.value = value;
    return _this11;
  }
  _inherits(BSONSymbol, _BSONValue12);
  return _createClass(BSONSymbol, [{
    key: "_bsontype",
    get: function get() {
      return 'BSONSymbol';
    }
  }, {
    key: "valueOf",
    value: function valueOf() {
      return this.value;
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.value;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.value;
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON() {
      return {
        $symbol: this.value
      };
    }
  }, {
    key: "inspect",
    value: function inspect(depth, options, _inspect21) {
      var _inspect22;
      (_inspect22 = _inspect21) !== null && _inspect22 !== void 0 ? _inspect22 : _inspect21 = defaultInspect;
      return "new BSONSymbol(".concat(_inspect21(this.value, options), ")");
    }
  }], [{
    key: "fromExtendedJSON",
    value: function fromExtendedJSON(doc) {
      return new BSONSymbol(doc.$symbol);
    }
  }]);
}(BSONValue);
var LongWithoutOverridesClass = _Long;
var _Timestamp = exports.Timestamp = /*#__PURE__*/function (_LongWithoutOverrides) {
  function Timestamp(low) {
    var _this12;
    _classCallCheck(this, Timestamp);
    if (low == null) {
      _this12 = _callSuper(this, Timestamp, [0, 0, true]);
    } else if (typeof low === 'bigint') {
      _this12 = _callSuper(this, Timestamp, [low, true]);
    } else if (_Long.isLong(low)) {
      _this12 = _callSuper(this, Timestamp, [low.low, low.high, true]);
    } else if (_typeof(low) === 'object' && 't' in low && 'i' in low) {
      if (typeof low.t !== 'number' && (_typeof(low.t) !== 'object' || low.t._bsontype !== 'Int32')) {
        throw new BSONError('Timestamp constructed from { t, i } must provide t as a number');
      }
      if (typeof low.i !== 'number' && (_typeof(low.i) !== 'object' || low.i._bsontype !== 'Int32')) {
        throw new BSONError('Timestamp constructed from { t, i } must provide i as a number');
      }
      var t = Number(low.t);
      var i = Number(low.i);
      if (t < 0 || Number.isNaN(t)) {
        throw new BSONError('Timestamp constructed from { t, i } must provide a positive t');
      }
      if (i < 0 || Number.isNaN(i)) {
        throw new BSONError('Timestamp constructed from { t, i } must provide a positive i');
      }
      if (t > 4294967295) {
        throw new BSONError('Timestamp constructed from { t, i } must provide t equal or less than uint32 max');
      }
      if (i > 4294967295) {
        throw new BSONError('Timestamp constructed from { t, i } must provide i equal or less than uint32 max');
      }
      _this12 = _callSuper(this, Timestamp, [i, t, true]);
    } else {
      throw new BSONError('A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }');
    }
    return _assertThisInitialized(_this12);
  }
  _inherits(Timestamp, _LongWithoutOverrides);
  return _createClass(Timestamp, [{
    key: "_bsontype",
    get: function get() {
      return 'Timestamp';
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        $timestamp: this.toString()
      };
    }
  }, {
    key: "toExtendedJSON",
    value: function toExtendedJSON() {
      return {
        $timestamp: {
          t: this.high >>> 0,
          i: this.low >>> 0
        }
      };
    }
  }, {
    key: "inspect",
    value: function inspect(depth, options, _inspect23) {
      var _inspect24;
      (_inspect24 = _inspect23) !== null && _inspect24 !== void 0 ? _inspect24 : _inspect23 = defaultInspect;
      var t = _inspect23(this.high >>> 0, options);
      var i = _inspect23(this.low >>> 0, options);
      return "new Timestamp({ t: ".concat(t, ", i: ").concat(i, " })");
    }
  }], [{
    key: "fromInt",
    value: function fromInt(value) {
      return new Timestamp(_Long.fromInt(value, true));
    }
  }, {
    key: "fromNumber",
    value: function fromNumber(value) {
      return new Timestamp(_Long.fromNumber(value, true));
    }
  }, {
    key: "fromBits",
    value: function fromBits(lowBits, highBits) {
      return new Timestamp({
        i: lowBits,
        t: highBits
      });
    }
  }, {
    key: "fromString",
    value: function fromString(str, optRadix) {
      return new Timestamp(_Long.fromString(str, true, optRadix));
    }
  }, {
    key: "fromExtendedJSON",
    value: function fromExtendedJSON(doc) {
      var i = _Long.isLong(doc.$timestamp.i) ? doc.$timestamp.i.getLowBitsUnsigned() : doc.$timestamp.i;
      var t = _Long.isLong(doc.$timestamp.t) ? doc.$timestamp.t.getLowBitsUnsigned() : doc.$timestamp.t;
      return new Timestamp({
        t: t,
        i: i
      });
    }
  }]);
}(LongWithoutOverridesClass);
_Timestamp.MAX_VALUE = _Long.MAX_UNSIGNED_VALUE;
var JS_INT_MAX_LONG = _Long.fromNumber(JS_INT_MAX);
var JS_INT_MIN_LONG = _Long.fromNumber(JS_INT_MIN);
function internalDeserialize(buffer, options, isArray) {
  options = options == null ? {} : options;
  var index = options && options.index ? options.index : 0;
  var size = NumberUtils.getInt32LE(buffer, index);
  if (size < 5) {
    throw new BSONError("bson size must be >= 5, is ".concat(size));
  }
  if (options.allowObjectSmallerThanBufferSize && buffer.length < size) {
    throw new BSONError("buffer length ".concat(buffer.length, " must be >= bson size ").concat(size));
  }
  if (!options.allowObjectSmallerThanBufferSize && buffer.length !== size) {
    throw new BSONError("buffer length ".concat(buffer.length, " must === bson size ").concat(size));
  }
  if (size + index > buffer.byteLength) {
    throw new BSONError("(bson size ".concat(size, " + options.index ").concat(index, " must be <= buffer length ").concat(buffer.byteLength, ")"));
  }
  if (buffer[index + size - 1] !== 0) {
    throw new BSONError("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
  }
  return deserializeObject(buffer, index, options, isArray);
}
var allowedDBRefKeys = /^\$ref$|^\$id$|^\$db$/;
function deserializeObject(buffer, index, options) {
  var _options$promoteBuffe, _options$promoteLongs, _options$promoteValue, _options$useBigInt;
  var isArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var fieldsAsRaw = options['fieldsAsRaw'] == null ? null : options['fieldsAsRaw'];
  var raw = options['raw'] == null ? false : options['raw'];
  var bsonRegExp = typeof options['bsonRegExp'] === 'boolean' ? options['bsonRegExp'] : false;
  var promoteBuffers = (_options$promoteBuffe = options.promoteBuffers) !== null && _options$promoteBuffe !== void 0 ? _options$promoteBuffe : false;
  var promoteLongs = (_options$promoteLongs = options.promoteLongs) !== null && _options$promoteLongs !== void 0 ? _options$promoteLongs : true;
  var promoteValues = (_options$promoteValue = options.promoteValues) !== null && _options$promoteValue !== void 0 ? _options$promoteValue : true;
  var useBigInt64 = (_options$useBigInt = options.useBigInt64) !== null && _options$useBigInt !== void 0 ? _options$useBigInt : false;
  if (useBigInt64 && !promoteValues) {
    throw new BSONError('Must either request bigint or Long for int64 deserialization');
  }
  if (useBigInt64 && !promoteLongs) {
    throw new BSONError('Must either request bigint or Long for int64 deserialization');
  }
  var validation = options.validation == null ? {
    utf8: true
  } : options.validation;
  var globalUTFValidation = true;
  var validationSetting;
  var utf8KeysSet;
  var utf8ValidatedKeys = validation.utf8;
  if (typeof utf8ValidatedKeys === 'boolean') {
    validationSetting = utf8ValidatedKeys;
  } else {
    globalUTFValidation = false;
    var utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function (key) {
      return utf8ValidatedKeys[key];
    });
    if (utf8ValidationValues.length === 0) {
      throw new BSONError('UTF-8 validation setting cannot be empty');
    }
    if (typeof utf8ValidationValues[0] !== 'boolean') {
      throw new BSONError('Invalid UTF-8 validation option, must specify boolean values');
    }
    validationSetting = utf8ValidationValues[0];
    if (!utf8ValidationValues.every(function (item) {
      return item === validationSetting;
    })) {
      throw new BSONError('Invalid UTF-8 validation option - keys must be all true or all false');
    }
  }
  if (!globalUTFValidation) {
    utf8KeysSet = new Set();
    for (var _i6 = 0, _Object$keys2 = Object.keys(utf8ValidatedKeys); _i6 < _Object$keys2.length; _i6++) {
      var key = _Object$keys2[_i6];
      utf8KeysSet.add(key);
    }
  }
  var startIndex = index;
  if (buffer.length < 5) throw new BSONError('corrupt bson message < 5 bytes long');
  var size = NumberUtils.getInt32LE(buffer, index);
  index += 4;
  if (size < 5 || size > buffer.length) throw new BSONError('corrupt bson message');
  var object = isArray ? [] : {};
  var arrayIndex = 0;
  var done = false;
  var isPossibleDBRef = isArray ? false : null;
  while (!done) {
    var _utf8KeysSet;
    var elementType = buffer[index++];
    if (elementType === 0) break;
    var i = index;
    while (buffer[i] !== 0x00 && i < buffer.length) {
      i++;
    }
    if (i >= buffer.byteLength) throw new BSONError('Bad BSON Document: illegal CString');
    var name = isArray ? arrayIndex++ : ByteUtils.toUTF8(buffer, index, i, false);
    var shouldValidateKey = true;
    if (globalUTFValidation || (_utf8KeysSet = utf8KeysSet) !== null && _utf8KeysSet !== void 0 && _utf8KeysSet.has(name)) {
      shouldValidateKey = validationSetting;
    } else {
      shouldValidateKey = !validationSetting;
    }
    if (isPossibleDBRef !== false && name[0] === '$') {
      isPossibleDBRef = allowedDBRefKeys.test(name);
    }
    var value = void 0;
    index = i + 1;
    if (elementType === BSON_DATA_STRING) {
      var stringSize = NumberUtils.getInt32LE(buffer, index);
      index += 4;
      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {
        throw new BSONError('bad string length in bson');
      }
      value = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);
      index = index + stringSize;
    } else if (elementType === BSON_DATA_OID) {
      var oid = ByteUtils.allocateUnsafe(12);
      for (var _i7 = 0; _i7 < 12; _i7++) oid[_i7] = buffer[index + _i7];
      value = new _ObjectId(oid);
      index = index + 12;
    } else if (elementType === BSON_DATA_INT && promoteValues === false) {
      value = new _Int(NumberUtils.getInt32LE(buffer, index));
      index += 4;
    } else if (elementType === BSON_DATA_INT) {
      value = NumberUtils.getInt32LE(buffer, index);
      index += 4;
    } else if (elementType === BSON_DATA_NUMBER) {
      value = NumberUtils.getFloat64LE(buffer, index);
      index += 8;
      if (promoteValues === false) value = new _Double(value);
    } else if (elementType === BSON_DATA_DATE) {
      var lowBits = NumberUtils.getInt32LE(buffer, index);
      var highBits = NumberUtils.getInt32LE(buffer, index + 4);
      index += 8;
      value = new Date(new _Long(lowBits, highBits).toNumber());
    } else if (elementType === BSON_DATA_BOOLEAN) {
      if (buffer[index] !== 0 && buffer[index] !== 1) throw new BSONError('illegal boolean type value');
      value = buffer[index++] === 1;
    } else if (elementType === BSON_DATA_OBJECT) {
      var _index = index;
      var objectSize = NumberUtils.getInt32LE(buffer, index);
      if (objectSize <= 0 || objectSize > buffer.length - index) throw new BSONError('bad embedded document length in bson');
      if (raw) {
        value = buffer.slice(index, index + objectSize);
      } else {
        var objectOptions = options;
        if (!globalUTFValidation) {
          objectOptions = _objectSpread(_objectSpread({}, options), {}, {
            validation: {
              utf8: shouldValidateKey
            }
          });
        }
        value = deserializeObject(buffer, _index, objectOptions, false);
      }
      index = index + objectSize;
    } else if (elementType === BSON_DATA_ARRAY) {
      var _index2 = index;
      var _objectSize = NumberUtils.getInt32LE(buffer, index);
      var arrayOptions = options;
      var stopIndex = index + _objectSize;
      if (fieldsAsRaw && fieldsAsRaw[name]) {
        arrayOptions = _objectSpread(_objectSpread({}, options), {}, {
          raw: true
        });
      }
      if (!globalUTFValidation) {
        arrayOptions = _objectSpread(_objectSpread({}, arrayOptions), {}, {
          validation: {
            utf8: shouldValidateKey
          }
        });
      }
      value = deserializeObject(buffer, _index2, arrayOptions, true);
      index = index + _objectSize;
      if (buffer[index - 1] !== 0) throw new BSONError('invalid array terminator byte');
      if (index !== stopIndex) throw new BSONError('corrupted array bson');
    } else if (elementType === BSON_DATA_UNDEFINED) {
      value = undefined;
    } else if (elementType === BSON_DATA_NULL) {
      value = null;
    } else if (elementType === BSON_DATA_LONG) {
      if (useBigInt64) {
        value = NumberUtils.getBigInt64LE(buffer, index);
        index += 8;
      } else {
        var _lowBits = NumberUtils.getInt32LE(buffer, index);
        var _highBits = NumberUtils.getInt32LE(buffer, index + 4);
        index += 8;
        var _long = new _Long(_lowBits, _highBits);
        if (promoteLongs && promoteValues === true) {
          value = _long.lessThanOrEqual(JS_INT_MAX_LONG) && _long.greaterThanOrEqual(JS_INT_MIN_LONG) ? _long.toNumber() : _long;
        } else {
          value = _long;
        }
      }
    } else if (elementType === BSON_DATA_DECIMAL128) {
      var bytes = ByteUtils.allocateUnsafe(16);
      for (var _i8 = 0; _i8 < 16; _i8++) bytes[_i8] = buffer[index + _i8];
      index = index + 16;
      value = new _Decimal(bytes);
    } else if (elementType === BSON_DATA_BINARY) {
      var binarySize = NumberUtils.getInt32LE(buffer, index);
      index += 4;
      var totalBinarySize = binarySize;
      var subType = buffer[index++];
      if (binarySize < 0) throw new BSONError('Negative binary type element size found');
      if (binarySize > buffer.byteLength) throw new BSONError('Binary type size larger than document size');
      if (buffer['slice'] != null) {
        if (subType === _Binary2.SUBTYPE_BYTE_ARRAY) {
          binarySize = NumberUtils.getInt32LE(buffer, index);
          index += 4;
          if (binarySize < 0) throw new BSONError('Negative binary type element size found for subtype 0x02');
          if (binarySize > totalBinarySize - 4) throw new BSONError('Binary type with subtype 0x02 contains too long binary size');
          if (binarySize < totalBinarySize - 4) throw new BSONError('Binary type with subtype 0x02 contains too short binary size');
        }
        if (promoteBuffers && promoteValues) {
          value = ByteUtils.toLocalBufferType(buffer.slice(index, index + binarySize));
        } else {
          value = new _Binary2(buffer.slice(index, index + binarySize), subType);
          if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {
            value = value.toUUID();
          }
        }
      } else {
        if (subType === _Binary2.SUBTYPE_BYTE_ARRAY) {
          binarySize = NumberUtils.getInt32LE(buffer, index);
          index += 4;
          if (binarySize < 0) throw new BSONError('Negative binary type element size found for subtype 0x02');
          if (binarySize > totalBinarySize - 4) throw new BSONError('Binary type with subtype 0x02 contains too long binary size');
          if (binarySize < totalBinarySize - 4) throw new BSONError('Binary type with subtype 0x02 contains too short binary size');
        }
        if (promoteBuffers && promoteValues) {
          value = ByteUtils.allocateUnsafe(binarySize);
          for (i = 0; i < binarySize; i++) {
            value[i] = buffer[index + i];
          }
        } else {
          value = new _Binary2(buffer.slice(index, index + binarySize), subType);
          if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {
            value = value.toUUID();
          }
        }
      }
      index = index + binarySize;
    } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) {
      i = index;
      while (buffer[i] !== 0x00 && i < buffer.length) {
        i++;
      }
      if (i >= buffer.length) throw new BSONError('Bad BSON Document: illegal CString');
      var source = ByteUtils.toUTF8(buffer, index, i, false);
      index = i + 1;
      i = index;
      while (buffer[i] !== 0x00 && i < buffer.length) {
        i++;
      }
      if (i >= buffer.length) throw new BSONError('Bad BSON Document: illegal CString');
      var regExpOptions = ByteUtils.toUTF8(buffer, index, i, false);
      index = i + 1;
      var optionsArray = new Array(regExpOptions.length);
      for (i = 0; i < regExpOptions.length; i++) {
        switch (regExpOptions[i]) {
          case 'm':
            optionsArray[i] = 'm';
            break;
          case 's':
            optionsArray[i] = 'g';
            break;
          case 'i':
            optionsArray[i] = 'i';
            break;
        }
      }
      value = new RegExp(source, optionsArray.join(''));
    } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) {
      i = index;
      while (buffer[i] !== 0x00 && i < buffer.length) {
        i++;
      }
      if (i >= buffer.length) throw new BSONError('Bad BSON Document: illegal CString');
      var _source = ByteUtils.toUTF8(buffer, index, i, false);
      index = i + 1;
      i = index;
      while (buffer[i] !== 0x00 && i < buffer.length) {
        i++;
      }
      if (i >= buffer.length) throw new BSONError('Bad BSON Document: illegal CString');
      var _regExpOptions = ByteUtils.toUTF8(buffer, index, i, false);
      index = i + 1;
      value = new _BSONRegExp(_source, _regExpOptions);
    } else if (elementType === BSON_DATA_SYMBOL) {
      var _stringSize = NumberUtils.getInt32LE(buffer, index);
      index += 4;
      if (_stringSize <= 0 || _stringSize > buffer.length - index || buffer[index + _stringSize - 1] !== 0) {
        throw new BSONError('bad string length in bson');
      }
      var symbol = ByteUtils.toUTF8(buffer, index, index + _stringSize - 1, shouldValidateKey);
      value = promoteValues ? symbol : new _BSONSymbol(symbol);
      index = index + _stringSize;
    } else if (elementType === BSON_DATA_TIMESTAMP) {
      value = new _Timestamp({
        i: NumberUtils.getUint32LE(buffer, index),
        t: NumberUtils.getUint32LE(buffer, index + 4)
      });
      index += 8;
    } else if (elementType === BSON_DATA_MIN_KEY) {
      value = new _MinKey();
    } else if (elementType === BSON_DATA_MAX_KEY) {
      value = new _MaxKey();
    } else if (elementType === BSON_DATA_CODE) {
      var _stringSize2 = NumberUtils.getInt32LE(buffer, index);
      index += 4;
      if (_stringSize2 <= 0 || _stringSize2 > buffer.length - index || buffer[index + _stringSize2 - 1] !== 0) {
        throw new BSONError('bad string length in bson');
      }
      var functionString = ByteUtils.toUTF8(buffer, index, index + _stringSize2 - 1, shouldValidateKey);
      value = new _Code(functionString);
      index = index + _stringSize2;
    } else if (elementType === BSON_DATA_CODE_W_SCOPE) {
      var totalSize = NumberUtils.getInt32LE(buffer, index);
      index += 4;
      if (totalSize < 4 + 4 + 4 + 1) {
        throw new BSONError('code_w_scope total size shorter minimum expected length');
      }
      var _stringSize3 = NumberUtils.getInt32LE(buffer, index);
      index += 4;
      if (_stringSize3 <= 0 || _stringSize3 > buffer.length - index || buffer[index + _stringSize3 - 1] !== 0) {
        throw new BSONError('bad string length in bson');
      }
      var _functionString = ByteUtils.toUTF8(buffer, index, index + _stringSize3 - 1, shouldValidateKey);
      index = index + _stringSize3;
      var _index3 = index;
      var _objectSize2 = NumberUtils.getInt32LE(buffer, index);
      var scopeObject = deserializeObject(buffer, _index3, options, false);
      index = index + _objectSize2;
      if (totalSize < 4 + 4 + _objectSize2 + _stringSize3) {
        throw new BSONError('code_w_scope total size is too short, truncating scope');
      }
      if (totalSize > 4 + 4 + _objectSize2 + _stringSize3) {
        throw new BSONError('code_w_scope total size is too long, clips outer document');
      }
      value = new _Code(_functionString, scopeObject);
    } else if (elementType === BSON_DATA_DBPOINTER) {
      var _stringSize4 = NumberUtils.getInt32LE(buffer, index);
      index += 4;
      if (_stringSize4 <= 0 || _stringSize4 > buffer.length - index || buffer[index + _stringSize4 - 1] !== 0) throw new BSONError('bad string length in bson');
      var namespace = ByteUtils.toUTF8(buffer, index, index + _stringSize4 - 1, shouldValidateKey);
      index = index + _stringSize4;
      var oidBuffer = ByteUtils.allocateUnsafe(12);
      for (var _i9 = 0; _i9 < 12; _i9++) oidBuffer[_i9] = buffer[index + _i9];
      var _oid = new _ObjectId(oidBuffer);
      index = index + 12;
      value = new _DBRef(namespace, _oid);
    } else {
      throw new BSONError("Detected unknown BSON type ".concat(elementType.toString(16), " for fieldname \"").concat(name, "\""));
    }
    if (name === '__proto__') {
      Object.defineProperty(object, name, {
        value: value,
        writable: true,
        enumerable: true,
        configurable: true
      });
    } else {
      object[name] = value;
    }
  }
  if (size !== index - startIndex) {
    if (isArray) throw new BSONError('corrupt array bson');
    throw new BSONError('corrupt object bson');
  }
  if (!isPossibleDBRef) return object;
  if (isDBRefLike(object)) {
    var copy = Object.assign({}, object);
    delete copy.$ref;
    delete copy.$id;
    delete copy.$db;
    return new _DBRef(object.$ref, object.$id, object.$db, copy);
  }
  return object;
}
var regexp = /\x00/;
var ignoreKeys = new Set(['$db', '$ref', '$id', '$clusterTime']);
function serializeString(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_STRING;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes + 1;
  buffer[index - 1] = 0;
  var size = ByteUtils.encodeUTF8Into(buffer, value, index + 4);
  NumberUtils.setInt32LE(buffer, index, size + 1);
  index = index + 4 + size;
  buffer[index++] = 0;
  return index;
}
function serializeNumber(buffer, key, value, index) {
  var isNegativeZero = Object.is(value, -0);
  var type = !isNegativeZero && Number.isSafeInteger(value) && value <= BSON_INT32_MAX && value >= BSON_INT32_MIN ? BSON_DATA_INT : BSON_DATA_NUMBER;
  buffer[index++] = type;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0x00;
  if (type === BSON_DATA_INT) {
    index += NumberUtils.setInt32LE(buffer, index, value);
  } else {
    index += NumberUtils.setFloat64LE(buffer, index, value);
  }
  return index;
}
function serializeBigInt(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_LONG;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index += numberOfWrittenBytes;
  buffer[index++] = 0;
  index += NumberUtils.setBigInt64LE(buffer, index, value);
  return index;
}
function serializeNull(buffer, key, _, index) {
  buffer[index++] = BSON_DATA_NULL;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  return index;
}
function serializeBoolean(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_BOOLEAN;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  buffer[index++] = value ? 1 : 0;
  return index;
}
function serializeDate(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_DATE;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  var dateInMilis = _Long.fromNumber(value.getTime());
  var lowBits = dateInMilis.getLowBits();
  var highBits = dateInMilis.getHighBits();
  index += NumberUtils.setInt32LE(buffer, index, lowBits);
  index += NumberUtils.setInt32LE(buffer, index, highBits);
  return index;
}
function serializeRegExp(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_REGEXP;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  if (value.source && value.source.match(regexp) != null) {
    throw new BSONError('value ' + value.source + ' must not contain null bytes');
  }
  index = index + ByteUtils.encodeUTF8Into(buffer, value.source, index);
  buffer[index++] = 0x00;
  if (value.ignoreCase) buffer[index++] = 0x69;
  if (value.global) buffer[index++] = 0x73;
  if (value.multiline) buffer[index++] = 0x6d;
  buffer[index++] = 0x00;
  return index;
}
function serializeBSONRegExp(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_REGEXP;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  if (value.pattern.match(regexp) != null) {
    throw new BSONError('pattern ' + value.pattern + ' must not contain null bytes');
  }
  index = index + ByteUtils.encodeUTF8Into(buffer, value.pattern, index);
  buffer[index++] = 0x00;
  var sortedOptions = value.options.split('').sort().join('');
  index = index + ByteUtils.encodeUTF8Into(buffer, sortedOptions, index);
  buffer[index++] = 0x00;
  return index;
}
function serializeMinMax(buffer, key, value, index) {
  if (value === null) {
    buffer[index++] = BSON_DATA_NULL;
  } else if (value._bsontype === 'MinKey') {
    buffer[index++] = BSON_DATA_MIN_KEY;
  } else {
    buffer[index++] = BSON_DATA_MAX_KEY;
  }
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  return index;
}
function serializeObjectId(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_OID;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  index += value.serializeInto(buffer, index);
  return index;
}
function serializeBuffer(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_BINARY;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  var size = value.length;
  index += NumberUtils.setInt32LE(buffer, index, size);
  buffer[index++] = BSON_BINARY_SUBTYPE_DEFAULT;
  if (size <= 16) {
    for (var i = 0; i < size; i++) buffer[index + i] = value[i];
  } else {
    buffer.set(value, index);
  }
  index = index + size;
  return index;
}
function serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path) {
  if (path.has(value)) {
    throw new BSONError('Cannot convert circular structure to BSON');
  }
  path.add(value);
  buffer[index++] = Array.isArray(value) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  var endIndex = serializeInto(buffer, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
  path["delete"](value);
  return endIndex;
}
function serializeDecimal128(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_DECIMAL128;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  for (var i = 0; i < 16; i++) buffer[index + i] = value.bytes[i];
  return index + 16;
}
function serializeLong(buffer, key, value, index) {
  buffer[index++] = value._bsontype === 'Long' ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  var lowBits = value.getLowBits();
  var highBits = value.getHighBits();
  index += NumberUtils.setInt32LE(buffer, index, lowBits);
  index += NumberUtils.setInt32LE(buffer, index, highBits);
  return index;
}
function serializeInt32(buffer, key, value, index) {
  value = value.valueOf();
  buffer[index++] = BSON_DATA_INT;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  index += NumberUtils.setInt32LE(buffer, index, value);
  return index;
}
function serializeDouble(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_NUMBER;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  index += NumberUtils.setFloat64LE(buffer, index, value.value);
  return index;
}
function serializeFunction(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_CODE;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  var functionString = value.toString();
  var size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;
  NumberUtils.setInt32LE(buffer, index, size);
  index = index + 4 + size - 1;
  buffer[index++] = 0;
  return index;
}
function serializeCode(buffer, key, value, index) {
  var checkKeys = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var depth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
  var serializeFunctions = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
  var ignoreUndefined = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : true;
  var path = arguments.length > 8 ? arguments[8] : undefined;
  if (value.scope && _typeof(value.scope) === 'object') {
    buffer[index++] = BSON_DATA_CODE_W_SCOPE;
    var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var startIndex = index;
    var functionString = value.code;
    index = index + 4;
    var codeSize = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;
    NumberUtils.setInt32LE(buffer, index, codeSize);
    buffer[index + 4 + codeSize - 1] = 0;
    index = index + codeSize + 4;
    var endIndex = serializeInto(buffer, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
    index = endIndex - 1;
    var totalSize = endIndex - startIndex;
    startIndex += NumberUtils.setInt32LE(buffer, startIndex, totalSize);
    buffer[index++] = 0;
  } else {
    buffer[index++] = BSON_DATA_CODE;
    var _numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
    index = index + _numberOfWrittenBytes;
    buffer[index++] = 0;
    var _functionString2 = value.code.toString();
    var size = ByteUtils.encodeUTF8Into(buffer, _functionString2, index + 4) + 1;
    NumberUtils.setInt32LE(buffer, index, size);
    index = index + 4 + size - 1;
    buffer[index++] = 0;
  }
  return index;
}
function serializeBinary(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_BINARY;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  var data = value.buffer;
  var size = value.position;
  if (value.sub_type === _Binary2.SUBTYPE_BYTE_ARRAY) size = size + 4;
  index += NumberUtils.setInt32LE(buffer, index, size);
  buffer[index++] = value.sub_type;
  if (value.sub_type === _Binary2.SUBTYPE_BYTE_ARRAY) {
    size = size - 4;
    index += NumberUtils.setInt32LE(buffer, index, size);
  }
  if (size <= 16) {
    for (var i = 0; i < size; i++) buffer[index + i] = data[i];
  } else {
    buffer.set(data, index);
  }
  index = index + value.position;
  return index;
}
function serializeSymbol(buffer, key, value, index) {
  buffer[index++] = BSON_DATA_SYMBOL;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  var size = ByteUtils.encodeUTF8Into(buffer, value.value, index + 4) + 1;
  NumberUtils.setInt32LE(buffer, index, size);
  index = index + 4 + size - 1;
  buffer[index++] = 0;
  return index;
}
function serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path) {
  buffer[index++] = BSON_DATA_OBJECT;
  var numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  var startIndex = index;
  var output = {
    $ref: value.collection || value.namespace,
    $id: value.oid
  };
  if (value.db != null) {
    output.$db = value.db;
  }
  output = Object.assign(output, value.fields);
  var endIndex = serializeInto(buffer, output, false, index, depth + 1, serializeFunctions, true, path);
  var size = endIndex - startIndex;
  startIndex += NumberUtils.setInt32LE(buffer, index, size);
  return endIndex;
}
function serializeInto(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {
  if (path == null) {
    if (object == null) {
      buffer[0] = 0x05;
      buffer[1] = 0x00;
      buffer[2] = 0x00;
      buffer[3] = 0x00;
      buffer[4] = 0x00;
      return 5;
    }
    if (Array.isArray(object)) {
      throw new BSONError('serialize does not support an array as the root input');
    }
    if (_typeof(object) !== 'object') {
      throw new BSONError('serialize does not support non-object as the root input');
    } else if ('_bsontype' in object && typeof object._bsontype === 'string') {
      throw new BSONError("BSON types cannot be serialized as a document");
    } else if (isDate(object) || isRegExp(object) || isUint8Array(object) || isAnyArrayBuffer(object)) {
      throw new BSONError("date, regexp, typedarray, and arraybuffer cannot be BSON documents");
    }
    path = new Set();
  }
  path.add(object);
  var index = startingIndex + 4;
  if (Array.isArray(object)) {
    for (var i = 0; i < object.length; i++) {
      var _value2;
      var key = "".concat(i);
      var value = object[i];
      if (typeof ((_value2 = value) === null || _value2 === void 0 ? void 0 : _value2.toBSON) === 'function') {
        value = value.toBSON();
      }
      if (typeof value === 'string') {
        index = serializeString(buffer, key, value, index);
      } else if (typeof value === 'number') {
        index = serializeNumber(buffer, key, value, index);
      } else if (typeof value === 'bigint') {
        index = serializeBigInt(buffer, key, value, index);
      } else if (typeof value === 'boolean') {
        index = serializeBoolean(buffer, key, value, index);
      } else if (value instanceof Date || isDate(value)) {
        index = serializeDate(buffer, key, value, index);
      } else if (value === undefined) {
        index = serializeNull(buffer, key, value, index);
      } else if (value === null) {
        index = serializeNull(buffer, key, value, index);
      } else if (isUint8Array(value)) {
        index = serializeBuffer(buffer, key, value, index);
      } else if (value instanceof RegExp || isRegExp(value)) {
        index = serializeRegExp(buffer, key, value, index);
      } else if (_typeof(value) === 'object' && value._bsontype == null) {
        index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
      } else if (_typeof(value) === 'object' && value[Symbol["for"]('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {
        throw new BSONVersionError();
      } else if (value._bsontype === 'ObjectId') {
        index = serializeObjectId(buffer, key, value, index);
      } else if (value._bsontype === 'Decimal128') {
        index = serializeDecimal128(buffer, key, value, index);
      } else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {
        index = serializeLong(buffer, key, value, index);
      } else if (value._bsontype === 'Double') {
        index = serializeDouble(buffer, key, value, index);
      } else if (typeof value === 'function' && serializeFunctions) {
        index = serializeFunction(buffer, key, value, index);
      } else if (value._bsontype === 'Code') {
        index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
      } else if (value._bsontype === 'Binary') {
        index = serializeBinary(buffer, key, value, index);
      } else if (value._bsontype === 'BSONSymbol') {
        index = serializeSymbol(buffer, key, value, index);
      } else if (value._bsontype === 'DBRef') {
        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);
      } else if (value._bsontype === 'BSONRegExp') {
        index = serializeBSONRegExp(buffer, key, value, index);
      } else if (value._bsontype === 'Int32') {
        index = serializeInt32(buffer, key, value, index);
      } else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {
        index = serializeMinMax(buffer, key, value, index);
      } else if (typeof value._bsontype !== 'undefined') {
        throw new BSONError("Unrecognized or invalid _bsontype: ".concat(String(value._bsontype)));
      }
    }
  } else if (object instanceof Map || isMap(object)) {
    var iterator = object.entries();
    var done = false;
    while (!done) {
      var _value4;
      var entry = iterator.next();
      done = !!entry.done;
      if (done) continue;
      var _key = entry.value[0];
      var _value3 = entry.value[1];
      if (typeof ((_value4 = _value3) === null || _value4 === void 0 ? void 0 : _value4.toBSON) === 'function') {
        _value3 = _value3.toBSON();
      }
      var type = _typeof(_value3);
      if (typeof _key === 'string' && !ignoreKeys.has(_key)) {
        if (_key.match(regexp) != null) {
          throw new BSONError('key ' + _key + ' must not contain null bytes');
        }
        if (checkKeys) {
          if ('$' === _key[0]) {
            throw new BSONError('key ' + _key + " must not start with '$'");
          } else if (_key.includes('.')) {
            throw new BSONError('key ' + _key + " must not contain '.'");
          }
        }
      }
      if (type === 'string') {
        index = serializeString(buffer, _key, _value3, index);
      } else if (type === 'number') {
        index = serializeNumber(buffer, _key, _value3, index);
      } else if (type === 'bigint') {
        index = serializeBigInt(buffer, _key, _value3, index);
      } else if (type === 'boolean') {
        index = serializeBoolean(buffer, _key, _value3, index);
      } else if (_value3 instanceof Date || isDate(_value3)) {
        index = serializeDate(buffer, _key, _value3, index);
      } else if (_value3 === null || _value3 === undefined && ignoreUndefined === false) {
        index = serializeNull(buffer, _key, _value3, index);
      } else if (isUint8Array(_value3)) {
        index = serializeBuffer(buffer, _key, _value3, index);
      } else if (_value3 instanceof RegExp || isRegExp(_value3)) {
        index = serializeRegExp(buffer, _key, _value3, index);
      } else if (type === 'object' && _value3._bsontype == null) {
        index = serializeObject(buffer, _key, _value3, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
      } else if (_typeof(_value3) === 'object' && _value3[Symbol["for"]('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {
        throw new BSONVersionError();
      } else if (_value3._bsontype === 'ObjectId') {
        index = serializeObjectId(buffer, _key, _value3, index);
      } else if (type === 'object' && _value3._bsontype === 'Decimal128') {
        index = serializeDecimal128(buffer, _key, _value3, index);
      } else if (_value3._bsontype === 'Long' || _value3._bsontype === 'Timestamp') {
        index = serializeLong(buffer, _key, _value3, index);
      } else if (_value3._bsontype === 'Double') {
        index = serializeDouble(buffer, _key, _value3, index);
      } else if (_value3._bsontype === 'Code') {
        index = serializeCode(buffer, _key, _value3, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
      } else if (typeof _value3 === 'function' && serializeFunctions) {
        index = serializeFunction(buffer, _key, _value3, index);
      } else if (_value3._bsontype === 'Binary') {
        index = serializeBinary(buffer, _key, _value3, index);
      } else if (_value3._bsontype === 'BSONSymbol') {
        index = serializeSymbol(buffer, _key, _value3, index);
      } else if (_value3._bsontype === 'DBRef') {
        index = serializeDBRef(buffer, _key, _value3, index, depth, serializeFunctions, path);
      } else if (_value3._bsontype === 'BSONRegExp') {
        index = serializeBSONRegExp(buffer, _key, _value3, index);
      } else if (_value3._bsontype === 'Int32') {
        index = serializeInt32(buffer, _key, _value3, index);
      } else if (_value3._bsontype === 'MinKey' || _value3._bsontype === 'MaxKey') {
        index = serializeMinMax(buffer, _key, _value3, index);
      } else if (typeof _value3._bsontype !== 'undefined') {
        throw new BSONError("Unrecognized or invalid _bsontype: ".concat(String(_value3._bsontype)));
      }
    }
  } else {
    var _object2;
    if (typeof ((_object2 = object) === null || _object2 === void 0 ? void 0 : _object2.toBSON) === 'function') {
      object = object.toBSON();
      if (object != null && _typeof(object) !== 'object') {
        throw new BSONError('toBSON function did not return an object');
      }
    }
    for (var _i10 = 0, _Object$keys3 = Object.keys(object); _i10 < _Object$keys3.length; _i10++) {
      var _value6;
      var _key2 = _Object$keys3[_i10];
      var _value5 = object[_key2];
      if (typeof ((_value6 = _value5) === null || _value6 === void 0 ? void 0 : _value6.toBSON) === 'function') {
        _value5 = _value5.toBSON();
      }
      var _type = _typeof(_value5);
      if (typeof _key2 === 'string' && !ignoreKeys.has(_key2)) {
        if (_key2.match(regexp) != null) {
          throw new BSONError('key ' + _key2 + ' must not contain null bytes');
        }
        if (checkKeys) {
          if ('$' === _key2[0]) {
            throw new BSONError('key ' + _key2 + " must not start with '$'");
          } else if (_key2.includes('.')) {
            throw new BSONError('key ' + _key2 + " must not contain '.'");
          }
        }
      }
      if (_type === 'string') {
        index = serializeString(buffer, _key2, _value5, index);
      } else if (_type === 'number') {
        index = serializeNumber(buffer, _key2, _value5, index);
      } else if (_type === 'bigint') {
        index = serializeBigInt(buffer, _key2, _value5, index);
      } else if (_type === 'boolean') {
        index = serializeBoolean(buffer, _key2, _value5, index);
      } else if (_value5 instanceof Date || isDate(_value5)) {
        index = serializeDate(buffer, _key2, _value5, index);
      } else if (_value5 === undefined) {
        if (ignoreUndefined === false) index = serializeNull(buffer, _key2, _value5, index);
      } else if (_value5 === null) {
        index = serializeNull(buffer, _key2, _value5, index);
      } else if (isUint8Array(_value5)) {
        index = serializeBuffer(buffer, _key2, _value5, index);
      } else if (_value5 instanceof RegExp || isRegExp(_value5)) {
        index = serializeRegExp(buffer, _key2, _value5, index);
      } else if (_type === 'object' && _value5._bsontype == null) {
        index = serializeObject(buffer, _key2, _value5, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
      } else if (_typeof(_value5) === 'object' && _value5[Symbol["for"]('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {
        throw new BSONVersionError();
      } else if (_value5._bsontype === 'ObjectId') {
        index = serializeObjectId(buffer, _key2, _value5, index);
      } else if (_type === 'object' && _value5._bsontype === 'Decimal128') {
        index = serializeDecimal128(buffer, _key2, _value5, index);
      } else if (_value5._bsontype === 'Long' || _value5._bsontype === 'Timestamp') {
        index = serializeLong(buffer, _key2, _value5, index);
      } else if (_value5._bsontype === 'Double') {
        index = serializeDouble(buffer, _key2, _value5, index);
      } else if (_value5._bsontype === 'Code') {
        index = serializeCode(buffer, _key2, _value5, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
      } else if (typeof _value5 === 'function' && serializeFunctions) {
        index = serializeFunction(buffer, _key2, _value5, index);
      } else if (_value5._bsontype === 'Binary') {
        index = serializeBinary(buffer, _key2, _value5, index);
      } else if (_value5._bsontype === 'BSONSymbol') {
        index = serializeSymbol(buffer, _key2, _value5, index);
      } else if (_value5._bsontype === 'DBRef') {
        index = serializeDBRef(buffer, _key2, _value5, index, depth, serializeFunctions, path);
      } else if (_value5._bsontype === 'BSONRegExp') {
        index = serializeBSONRegExp(buffer, _key2, _value5, index);
      } else if (_value5._bsontype === 'Int32') {
        index = serializeInt32(buffer, _key2, _value5, index);
      } else if (_value5._bsontype === 'MinKey' || _value5._bsontype === 'MaxKey') {
        index = serializeMinMax(buffer, _key2, _value5, index);
      } else if (typeof _value5._bsontype !== 'undefined') {
        throw new BSONError("Unrecognized or invalid _bsontype: ".concat(String(_value5._bsontype)));
      }
    }
  }
  path["delete"](object);
  buffer[index++] = 0x00;
  var size = index - startingIndex;
  startingIndex += NumberUtils.setInt32LE(buffer, startingIndex, size);
  return index;
}
function isBSONType(value) {
  return value != null && _typeof(value) === 'object' && '_bsontype' in value && typeof value._bsontype === 'string';
}
var keysToCodecs = {
  $oid: _ObjectId,
  $binary: _Binary2,
  $uuid: _Binary2,
  $symbol: _BSONSymbol,
  $numberInt: _Int,
  $numberDecimal: _Decimal,
  $numberDouble: _Double,
  $numberLong: _Long,
  $minKey: _MinKey,
  $maxKey: _MaxKey,
  $regex: _BSONRegExp,
  $regularExpression: _BSONRegExp,
  $timestamp: _Timestamp
};
function deserializeValue(value) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (typeof value === 'number') {
    var in32BitRange = value <= BSON_INT32_MAX && value >= BSON_INT32_MIN;
    var in64BitRange = value <= BSON_INT64_MAX && value >= BSON_INT64_MIN;
    if (options.relaxed || options.legacy) {
      return value;
    }
    if (Number.isInteger(value) && !Object.is(value, -0)) {
      if (in32BitRange) {
        return new _Int(value);
      }
      if (in64BitRange) {
        if (options.useBigInt64) {
          return BigInt(value);
        }
        return _Long.fromNumber(value);
      }
    }
    return new _Double(value);
  }
  if (value == null || _typeof(value) !== 'object') return value;
  if (value.$undefined) return null;
  var keys = Object.keys(value).filter(function (k) {
    return k.startsWith('$') && value[k] != null;
  });
  for (var i = 0; i < keys.length; i++) {
    var c = keysToCodecs[keys[i]];
    if (c) return c.fromExtendedJSON(value, options);
  }
  if (value.$date != null) {
    var d = value.$date;
    var date = new Date();
    if (options.legacy) {
      if (typeof d === 'number') date.setTime(d);else if (typeof d === 'string') date.setTime(Date.parse(d));else if (typeof d === 'bigint') date.setTime(Number(d));else throw new BSONRuntimeError("Unrecognized type for EJSON date: ".concat(_typeof(d)));
    } else {
      if (typeof d === 'string') date.setTime(Date.parse(d));else if (_Long.isLong(d)) date.setTime(d.toNumber());else if (typeof d === 'number' && options.relaxed) date.setTime(d);else if (typeof d === 'bigint') date.setTime(Number(d));else throw new BSONRuntimeError("Unrecognized type for EJSON date: ".concat(_typeof(d)));
    }
    return date;
  }
  if (value.$code != null) {
    var copy = Object.assign({}, value);
    if (value.$scope) {
      copy.$scope = deserializeValue(value.$scope);
    }
    return _Code.fromExtendedJSON(value);
  }
  if (isDBRefLike(value) || value.$dbPointer) {
    var v = value.$ref ? value : value.$dbPointer;
    if (v instanceof _DBRef) return v;
    var dollarKeys = Object.keys(v).filter(function (k) {
      return k.startsWith('$');
    });
    var valid = true;
    dollarKeys.forEach(function (k) {
      if (['$ref', '$id', '$db'].indexOf(k) === -1) valid = false;
    });
    if (valid) return _DBRef.fromExtendedJSON(v);
  }
  return value;
}
function serializeArray(array, options) {
  return array.map(function (v, index) {
    options.seenObjects.push({
      propertyName: "index ".concat(index),
      obj: null
    });
    try {
      return serializeValue(v, options);
    } finally {
      options.seenObjects.pop();
    }
  });
}
function getISOString(date) {
  var isoStr = date.toISOString();
  return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + 'Z';
}
function serializeValue(value, options) {
  if (value instanceof Map || isMap(value)) {
    var obj = Object.create(null);
    var _iterator = _createForOfIteratorHelper(value),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = _slicedToArray(_step.value, 2),
          k = _step$value[0],
          v = _step$value[1];
        if (typeof k !== 'string') {
          throw new BSONError('Can only serialize maps with string keys');
        }
        obj[k] = v;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return serializeValue(obj, options);
  }
  if ((_typeof(value) === 'object' || typeof value === 'function') && value !== null) {
    var index = options.seenObjects.findIndex(function (entry) {
      return entry.obj === value;
    });
    if (index !== -1) {
      var props = options.seenObjects.map(function (entry) {
        return entry.propertyName;
      });
      var leadingPart = props.slice(0, index).map(function (prop) {
        return "".concat(prop, " -> ");
      }).join('');
      var alreadySeen = props[index];
      var circularPart = ' -> ' + props.slice(index + 1, props.length - 1).map(function (prop) {
        return "".concat(prop, " -> ");
      }).join('');
      var current = props[props.length - 1];
      var leadingSpace = ' '.repeat(leadingPart.length + alreadySeen.length / 2);
      var dashes = '-'.repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);
      throw new BSONError('Converting circular structure to EJSON:\n' + "    ".concat(leadingPart).concat(alreadySeen).concat(circularPart).concat(current, "\n") + "    ".concat(leadingSpace, "\\").concat(dashes, "/"));
    }
    options.seenObjects[options.seenObjects.length - 1].obj = value;
  }
  if (Array.isArray(value)) return serializeArray(value, options);
  if (value === undefined) return null;
  if (value instanceof Date || isDate(value)) {
    var dateNum = value.getTime(),
      inRange = dateNum > -1 && dateNum < 253402318800000;
    if (options.legacy) {
      return options.relaxed && inRange ? {
        $date: value.getTime()
      } : {
        $date: getISOString(value)
      };
    }
    return options.relaxed && inRange ? {
      $date: getISOString(value)
    } : {
      $date: {
        $numberLong: value.getTime().toString()
      }
    };
  }
  if (typeof value === 'number' && (!options.relaxed || !isFinite(value))) {
    if (Number.isInteger(value) && !Object.is(value, -0)) {
      if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {
        return {
          $numberInt: value.toString()
        };
      }
      if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) {
        return {
          $numberLong: value.toString()
        };
      }
    }
    return {
      $numberDouble: Object.is(value, -0) ? '-0.0' : value.toString()
    };
  }
  if (typeof value === 'bigint') {
    if (!options.relaxed) {
      return {
        $numberLong: BigInt.asIntN(64, value).toString()
      };
    }
    return Number(BigInt.asIntN(64, value));
  }
  if (value instanceof RegExp || isRegExp(value)) {
    var flags = value.flags;
    if (flags === undefined) {
      var match = value.toString().match(/[gimuy]*$/);
      if (match) {
        flags = match[0];
      }
    }
    var rx = new _BSONRegExp(value.source, flags);
    return rx.toExtendedJSON(options);
  }
  if (value != null && _typeof(value) === 'object') return serializeDocument(value, options);
  return value;
}
var BSON_TYPE_MAPPINGS = {
  Binary: function Binary(o) {
    return new _Binary2(o.value(), o.sub_type);
  },
  Code: function Code(o) {
    return new _Code(o.code, o.scope);
  },
  DBRef: function DBRef(o) {
    return new _DBRef(o.collection || o.namespace, o.oid, o.db, o.fields);
  },
  Decimal128: function Decimal128(o) {
    return new _Decimal(o.bytes);
  },
  Double: function Double(o) {
    return new _Double(o.value);
  },
  Int32: function Int32(o) {
    return new _Int(o.value);
  },
  Long: function Long(o) {
    return _Long.fromBits(o.low != null ? o.low : o.low_, o.low != null ? o.high : o.high_, o.low != null ? o.unsigned : o.unsigned_);
  },
  MaxKey: function MaxKey() {
    return new _MaxKey();
  },
  MinKey: function MinKey() {
    return new _MinKey();
  },
  ObjectId: function ObjectId(o) {
    return new _ObjectId(o);
  },
  BSONRegExp: function BSONRegExp(o) {
    return new _BSONRegExp(o.pattern, o.options);
  },
  BSONSymbol: function BSONSymbol(o) {
    return new _BSONSymbol(o.value);
  },
  Timestamp: function Timestamp(o) {
    return _Timestamp.fromBits(o.low, o.high);
  }
};
function serializeDocument(doc, options) {
  if (doc == null || _typeof(doc) !== 'object') throw new BSONError('not an object instance');
  var bsontype = doc._bsontype;
  if (typeof bsontype === 'undefined') {
    var _doc = {};
    for (var _i11 = 0, _Object$keys4 = Object.keys(doc); _i11 < _Object$keys4.length; _i11++) {
      var name = _Object$keys4[_i11];
      options.seenObjects.push({
        propertyName: name,
        obj: null
      });
      try {
        var value = serializeValue(doc[name], options);
        if (name === '__proto__') {
          Object.defineProperty(_doc, name, {
            value: value,
            writable: true,
            enumerable: true,
            configurable: true
          });
        } else {
          _doc[name] = value;
        }
      } finally {
        options.seenObjects.pop();
      }
    }
    return _doc;
  } else if (doc != null && _typeof(doc) === 'object' && typeof doc._bsontype === 'string' && doc[Symbol["for"]('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {
    throw new BSONVersionError();
  } else if (isBSONType(doc)) {
    var outDoc = doc;
    if (typeof outDoc.toExtendedJSON !== 'function') {
      var mapper = BSON_TYPE_MAPPINGS[doc._bsontype];
      if (!mapper) {
        throw new BSONError('Unrecognized or invalid _bsontype: ' + doc._bsontype);
      }
      outDoc = mapper(outDoc);
    }
    if (bsontype === 'Code' && outDoc.scope) {
      outDoc = new _Code(outDoc.code, serializeValue(outDoc.scope, options));
    } else if (bsontype === 'DBRef' && outDoc.oid) {
      outDoc = new _DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));
    }
    return outDoc.toExtendedJSON(options);
  } else {
    throw new BSONError('_bsontype must be a string, but was: ' + _typeof(bsontype));
  }
}
function parse(text, options) {
  var _options$useBigInt2, _options$relaxed, _options$legacy;
  var ejsonOptions = {
    useBigInt64: (_options$useBigInt2 = options === null || options === void 0 ? void 0 : options.useBigInt64) !== null && _options$useBigInt2 !== void 0 ? _options$useBigInt2 : false,
    relaxed: (_options$relaxed = options === null || options === void 0 ? void 0 : options.relaxed) !== null && _options$relaxed !== void 0 ? _options$relaxed : true,
    legacy: (_options$legacy = options === null || options === void 0 ? void 0 : options.legacy) !== null && _options$legacy !== void 0 ? _options$legacy : false
  };
  return JSON.parse(text, function (key, value) {
    if (key.indexOf('\x00') !== -1) {
      throw new BSONError("BSON Document field names cannot contain null bytes, found: ".concat(JSON.stringify(key)));
    }
    return deserializeValue(value, ejsonOptions);
  });
}
function stringify(value, replacer, space, options) {
  if (space != null && _typeof(space) === 'object') {
    options = space;
    space = 0;
  }
  if (replacer != null && _typeof(replacer) === 'object' && !Array.isArray(replacer)) {
    options = replacer;
    replacer = undefined;
    space = 0;
  }
  var serializeOptions = Object.assign({
    relaxed: true,
    legacy: false
  }, options, {
    seenObjects: [{
      propertyName: '(root)',
      obj: null
    }]
  });
  var doc = serializeValue(value, serializeOptions);
  return JSON.stringify(doc, replacer, space);
}
function EJSONserialize(value, options) {
  options = options || {};
  return JSON.parse(stringify(value, options));
}
function EJSONdeserialize(ejson, options) {
  options = options || {};
  return parse(JSON.stringify(ejson), options);
}
var EJSON = exports.EJSON = Object.create(null);
EJSON.parse = parse;
EJSON.stringify = stringify;
EJSON.serialize = EJSONserialize;
EJSON.deserialize = EJSONdeserialize;
Object.freeze(EJSON);
function getSize(source, offset) {
  try {
    return NumberUtils.getNonnegativeInt32LE(source, offset);
  } catch (cause) {
    throw new BSONOffsetError('BSON size cannot be negative', offset, {
      cause: cause
    });
  }
}
function findNull(bytes, offset) {
  var nullTerminatorOffset = offset;
  for (; bytes[nullTerminatorOffset] !== 0x00; nullTerminatorOffset++);
  if (nullTerminatorOffset === bytes.length - 1) {
    throw new BSONOffsetError('Null terminator not found', offset);
  }
  return nullTerminatorOffset;
}
function parseToElements(bytes) {
  var _startOffset;
  var startOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  (_startOffset = startOffset) !== null && _startOffset !== void 0 ? _startOffset : startOffset = 0;
  if (bytes.length < 5) {
    throw new BSONOffsetError("Input must be at least 5 bytes, got ".concat(bytes.length, " bytes"), startOffset);
  }
  var documentSize = getSize(bytes, startOffset);
  if (documentSize > bytes.length - startOffset) {
    throw new BSONOffsetError("Parsed documentSize (".concat(documentSize, " bytes) does not match input length (").concat(bytes.length, " bytes)"), startOffset);
  }
  if (bytes[startOffset + documentSize - 1] !== 0x00) {
    throw new BSONOffsetError('BSON documents must end in 0x00', startOffset + documentSize);
  }
  var elements = [];
  var offset = startOffset + 4;
  while (offset <= documentSize + startOffset) {
    var type = bytes[offset];
    offset += 1;
    if (type === 0) {
      if (offset - startOffset !== documentSize) {
        throw new BSONOffsetError("Invalid 0x00 type byte", offset);
      }
      break;
    }
    var nameOffset = offset;
    var nameLength = findNull(bytes, offset) - nameOffset;
    offset += nameLength + 1;
    var length = void 0;
    if (type === 1 || type === 18 || type === 9 || type === 17) {
      length = 8;
    } else if (type === 16) {
      length = 4;
    } else if (type === 7) {
      length = 12;
    } else if (type === 19) {
      length = 16;
    } else if (type === 8) {
      length = 1;
    } else if (type === 10 || type === 6 || type === 127 || type === 255) {
      length = 0;
    } else if (type === 11) {
      length = findNull(bytes, findNull(bytes, offset) + 1) + 1 - offset;
    } else if (type === 3 || type === 4 || type === 15) {
      length = getSize(bytes, offset);
    } else if (type === 2 || type === 5 || type === 12 || type === 13 || type === 14) {
      length = getSize(bytes, offset) + 4;
      if (type === 5) {
        length += 1;
      }
      if (type === 12) {
        length += 12;
      }
    } else {
      throw new BSONOffsetError("Invalid 0x".concat(type.toString(16).padStart(2, '0'), " type byte"), offset);
    }
    if (length > documentSize) {
      throw new BSONOffsetError('value reports length larger than document', offset);
    }
    elements.push([type, nameOffset, nameLength, offset, length]);
    offset += length;
  }
  return elements;
}
var onDemand = exports.onDemand = Object.create(null);
onDemand.parseToElements = parseToElements;
onDemand.ByteUtils = ByteUtils;
onDemand.NumberUtils = NumberUtils;
Object.freeze(onDemand);
var MAXSIZE = 1024 * 1024 * 17;
var buffer = ByteUtils.allocate(MAXSIZE);
function setInternalBufferSize(size) {
  if (buffer.length < size) {
    buffer = ByteUtils.allocate(size);
  }
}
function serialize(object) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;
  var serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
  var ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;
  var minInternalBufferSize = typeof options.minInternalBufferSize === 'number' ? options.minInternalBufferSize : MAXSIZE;
  if (buffer.length < minInternalBufferSize) {
    buffer = ByteUtils.allocate(minInternalBufferSize);
  }
  var serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
  var finishedBuffer = ByteUtils.allocateUnsafe(serializationIndex);
  finishedBuffer.set(buffer.subarray(0, serializationIndex), 0);
  return finishedBuffer;
}
function serializeWithBufferAndIndex(object, finalBuffer) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;
  var serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
  var ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;
  var startIndex = typeof options.index === 'number' ? options.index : 0;
  var serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
  finalBuffer.set(buffer.subarray(0, serializationIndex), startIndex);
  return startIndex + serializationIndex - 1;
}
function deserialize(buffer) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return internalDeserialize(ByteUtils.toLocalBufferType(buffer), options);
}
function calculateObjectSize(object) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  options = options || {};
  var serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
  var ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;
  return internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined);
}
function deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
  var internalOptions = Object.assign({
    allowObjectSmallerThanBufferSize: true,
    index: 0
  }, options);
  var bufferData = ByteUtils.toLocalBufferType(data);
  var index = startIndex;
  for (var i = 0; i < numberOfDocuments; i++) {
    var size = NumberUtils.getInt32LE(bufferData, index);
    internalOptions.index = index;
    documents[docStartIndex + i] = internalDeserialize(bufferData, internalOptions);
    index = index + size;
  }
  return index;
}
var bson = exports.BSON = /*#__PURE__*/Object.freeze({
  __proto__: null,
  BSONError: BSONError,
  BSONOffsetError: BSONOffsetError,
  BSONRegExp: _BSONRegExp,
  BSONRuntimeError: BSONRuntimeError,
  BSONSymbol: _BSONSymbol,
  BSONType: BSONType,
  BSONValue: BSONValue,
  BSONVersionError: BSONVersionError,
  Binary: _Binary2,
  Code: _Code,
  DBRef: _DBRef,
  Decimal128: _Decimal,
  Double: _Double,
  EJSON: EJSON,
  Int32: _Int,
  Long: _Long,
  MaxKey: _MaxKey,
  MinKey: _MinKey,
  ObjectId: _ObjectId,
  Timestamp: _Timestamp,
  UUID: UUID,
  calculateObjectSize: calculateObjectSize,
  deserialize: deserialize,
  deserializeStream: deserializeStream,
  onDemand: onDemand,
  serialize: serialize,
  serializeWithBufferAndIndex: serializeWithBufferAndIndex,
  setInternalBufferSize: setInternalBufferSize
});